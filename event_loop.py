# -*- coding: utf-8 -*-
"""Event_LOOP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v6gxM9b6FUhzM8_zSVlsglIlwQyORKd0
"""

!pip install -q gradio
print("Gradio installed.")

import gradio as gr
import json
import random
from datetime import datetime, date
from pathlib import Path
from typing import Dict, List, Any
from copy import deepcopy

# ------------------ HYPOTHETICAL CAMPUS SCENARIO ------------------

# We assume a small campus with 5 APs
AP_IDS = [
    "ap_exam_1",      # inside exam hall
    "ap_exam_2",      # inside exam hall
    "ap_corridor_1",  # outside, but near exam hall
    "ap_corridor_2",  # outside, but near exam hall
    "ap_canteen",     # far away
]

# Initial baseline configs (what slow-loop RL would have decided "normally")
INITIAL_AP_BASELINE_CONFIG: Dict[str, Dict[str, Any]] = {
    "ap_exam_1": {
        "channel": 1,
        "bandwidth": 40,
        "txpower": 15.0,
        "fast_loop_mode": "normal",
    },
    "ap_exam_2": {
        "channel": 6,
        "bandwidth": 40,
        "txpower": 15.0,
        "fast_loop_mode": "normal",
    },
    "ap_corridor_1": {
        "channel": 1,
        "bandwidth": 40,
        "txpower": 17.0,
        "fast_loop_mode": "normal",
    },
    "ap_corridor_2": {
        "channel": 11,
        "bandwidth": 40,
        "txpower": 17.0,
        "fast_loop_mode": "normal",
    },
    "ap_canteen": {
        "channel": 36,
        "bandwidth": 40,
        "txpower": 20.0,
        "fast_loop_mode": "normal",
    },
}

# Runtime mutable baseline config (what the controller is currently using)
AP_BASELINE_CONFIG: Dict[str, Dict[str, Any]] = deepcopy(INITIAL_AP_BASELINE_CONFIG)

# Simplified telemetry for each AP
TELEMETRY: Dict[str, Dict[str, Any]] = {
    ap_id: {
        "ap_id": ap_id,
        "channel": cfg["channel"],
        "bandwidth": cfg["bandwidth"],
        "txpower": cfg["txpower"],
        "num_clients": 0,
        "interference": False,
    }
    for ap_id, cfg in AP_BASELINE_CONFIG.items()
}

# Where we store user-defined exam schedules
SCHEDULE_FILE = Path("exam_schedules.json")

def load_schedules() -> List[Dict[str, Any]]:
    if SCHEDULE_FILE.exists():
        return json.loads(SCHEDULE_FILE.read_text())
    return []

def save_schedules(schedules: List[Dict[str, Any]]) -> None:
    SCHEDULE_FILE.write_text(json.dumps(schedules, indent=2))

def parse_ap_list(text: str) -> List[str]:
    return [x.strip() for x in text.split(",") if x.strip()]

def reset_simulation_state() -> None:
    """Reset AP configs and telemetry to initial values."""
    global AP_BASELINE_CONFIG, TELEMETRY, EXAM_HALL_STATE
    AP_BASELINE_CONFIG = deepcopy(INITIAL_AP_BASELINE_CONFIG)
    TELEMETRY = {
        ap_id: {
            "ap_id": ap_id,
            "channel": cfg["channel"],
            "bandwidth": cfg["bandwidth"],
            "txpower": cfg["txpower"],
            "num_clients": 0,
            "interference": False,
        }
        for ap_id, cfg in AP_BASELINE_CONFIG.items()
    }
    # Reset event state as well (will be defined in next cell)
    EXAM_HALL_STATE["active"] = False
    EXAM_HALL_STATE["backup_configs"] = {}
    EXAM_HALL_STATE["exam_aps"] = set()
    EXAM_HALL_STATE["neighbor_aps"] = set()
    EXAM_HALL_STATE["policy"] = {}
    print("Simulation state reset.")

from datetime import time as _time

# ------------------ EXAM HALL EVENT LOOP STATE ------------------

EXAM_HALL_STATE: Dict[str, Any] = {
    "active": False,
    "backup_configs": {},   # ap_id -> snapshot
    "exam_aps": set(),      # from schedule
    "neighbor_aps": set(),  # from schedule
    "policy": {},           # from schedule
}

def schedule_exam_entry(
    exam_date: str,
    start_time: str,
    end_time: str,
    exam_aps_text: str,
    neighbor_aps_text: str,
    power_boost_db: int,
    power_reduce_db: int,
    force_20_mhz: bool,
    conservative_mode: bool,
):
    """
    Used by the GUI to create a schedule entry and save it.
    """
    # Basic validation
    if not exam_date:
        return "âŒ Please choose an exam date (YYYY-MM-DD).", {}

    if not start_time or not end_time:
        return "âŒ Please provide both start and end time (HH:MM).", {}

    try:
        _ = datetime.strptime(exam_date, "%Y-%m-%d").date()
    except ValueError:
        return "âŒ Exam date must be in YYYY-MM-DD format.", {}

    try:
        start_t = datetime.strptime(start_time, "%H:%M").time()
        end_t = datetime.strptime(end_time, "%H:%M").time()
    except ValueError:
        return "âŒ Time must be in HH:MM format (e.g., 09:00).", {}

    if start_t >= end_t:
        return "âŒ Start time must be before end time.", {}

    exam_aps = parse_ap_list(exam_aps_text)
    neighbor_aps = parse_ap_list(neighbor_aps_text)

    if not exam_aps:
        return "âŒ Please provide at least one exam hall AP ID.", {}

    now = datetime.now().isoformat(timespec="seconds")
    new_entry: Dict[str, Any] = {
        "type": "EXAM_HALL_QUIET_HOURS",
        "date": exam_date,
        "start_time": start_t.strftime("%H:%M:%S"),
        "end_time": end_t.strftime("%H:%M:%S"),
        "exam_aps": exam_aps,
        "neighbor_aps": neighbor_aps,
        "policy": {
            "power_boost_db": power_boost_db,
            "power_reduce_db": power_reduce_db,
            "force_20_mhz": force_20_mhz,
            "conservative_mode": conservative_mode,
        },
        "created_at": now,
    }

    schedules = load_schedules()
    schedules.append(new_entry)
    save_schedules(schedules)

    return " Exam hall quiet hours scheduled and saved to exam_schedules.json", new_entry

def view_schedules() -> Dict[str, Any]:
    return {"schedules": load_schedules()}

# ------------------ EXAM HALL EVENT HANDLER ------------------

def _handle_exam_hall_phase(phase: str) -> List[Dict[str, Any]]:
    """
    Apply 'enter' / 'exit' policy based on EXAM_HALL_STATE.
    Uses and updates AP_BASELINE_CONFIG.
    """
    global AP_BASELINE_CONFIG
    proposals: List[Dict[str, Any]] = []

    exam_aps = EXAM_HALL_STATE["exam_aps"]
    neighbor_aps = EXAM_HALL_STATE["neighbor_aps"]
    policy = EXAM_HALL_STATE["policy"]

    if phase == "enter":
        if EXAM_HALL_STATE["active"]:
            return proposals

        EXAM_HALL_STATE["active"] = True
        EXAM_HALL_STATE["backup_configs"] = {}

        # snapshot configs
        for ap_id in exam_aps | neighbor_aps:
            if ap_id in AP_BASELINE_CONFIG:
                EXAM_HALL_STATE["backup_configs"][ap_id] = deepcopy(AP_BASELINE_CONFIG[ap_id])

        power_boost_db = policy.get("power_boost_db", 3)
        power_reduce_db = policy.get("power_reduce_db", 3)
        force_20_mhz = policy.get("force_20_mhz", True)
        conservative_mode = policy.get("conservative_mode", True)

        EXAM_AP_MAX_POWER_DBM = 22.0
        NEIGHBOR_AP_MIN_POWER_DBM = 5.0

        # exam AP policy
        for ap_id in exam_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cur = AP_BASELINE_CONFIG[ap_id]

            if force_20_mhz and cur.get("bandwidth") != 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "EXAM_ENTER_FORCE_20MHZ",
                })
                cur["bandwidth"] = 20

            if conservative_mode and cur.get("fast_loop_mode") != "conservative":
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": "conservative",
                    "reason": "EXAM_ENTER_CONSERVATIVE",
                })
                cur["fast_loop_mode"] = "conservative"

            old_pwr = float(cur.get("txpower", 15.0))
            boosted = min(old_pwr + power_boost_db, EXAM_AP_MAX_POWER_DBM)
            if boosted != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": boosted,
                    "reason": "EXAM_ENTER_POWER_BOOST",
                })
                cur["txpower"] = boosted

        # neighbor AP policy
        for ap_id in neighbor_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cur = AP_BASELINE_CONFIG[ap_id]
            old_pwr = float(cur.get("txpower", 15.0))
            reduced = max(old_pwr - power_reduce_db, NEIGHBOR_AP_MIN_POWER_DBM)
            if reduced != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": reduced,
                    "reason": "EXAM_ENTER_NEIGHBOR_POWER_REDUCE",
                })
                cur["txpower"] = reduced

        return proposals

    elif phase == "exit":
        if not EXAM_HALL_STATE["active"]:
            return proposals

        EXAM_HALL_STATE["active"] = False

        for ap_id, prev_cfg in EXAM_HALL_STATE["backup_configs"].items():
            cur = AP_BASELINE_CONFIG.get(ap_id, {})
            for field in ("bandwidth", "fast_loop_mode", "txpower"):
                if field in prev_cfg and cur.get(field) != prev_cfg[field]:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": field,
                        "value": prev_cfg[field],
                        "reason": "EXAM_EXIT_RESTORE",
                    })
                    cur[field] = prev_cfg[field]

        EXAM_HALL_STATE["backup_configs"] = {}
        EXAM_HALL_STATE["exam_aps"] = set()
        EXAM_HALL_STATE["neighbor_aps"] = set()
        EXAM_HALL_STATE["policy"] = {}
        return proposals

    else:
        raise ValueError(f"Unknown exam phase {phase}")

def exam_hall_event_tick(now: datetime) -> List[Dict[str, Any]]:
    """
    Event loop hook for exam hall.
    - Reads last EXAM_HALL_QUIET_HOURS schedule (if any).
    - Decides if we should enter/exit exam mode at 'now'.
    - Returns proposals from _handle_exam_hall_phase.
    """
    schedules = [s for s in load_schedules() if s.get("type") == "EXAM_HALL_QUIET_HOURS"]
    if not schedules:
        # no schedules, if active -> exit
        if EXAM_HALL_STATE["active"]:
            return _handle_exam_hall_phase("exit")
        return []

    # For PoC, just take the latest schedule
    sched = schedules[-1]

    exam_date = datetime.strptime(sched["date"], "%Y-%m-%d").date()
    start_t = datetime.strptime(sched["start_time"], "%H:%M:%S").time()
    end_t = datetime.strptime(sched["end_time"], "%H:%M:%S").time()

    # build datetime window
    start_dt = datetime.combine(exam_date, start_t)
    end_dt = datetime.combine(exam_date, end_t)

    # populate state with schedule data before entering
    EXAM_HALL_STATE["exam_aps"] = set(sched["exam_aps"])
    EXAM_HALL_STATE["neighbor_aps"] = set(sched["neighbor_aps"])
    EXAM_HALL_STATE["policy"] = sched["policy"]

    active = EXAM_HALL_STATE["active"]

    if start_dt <= now <= end_dt and not active:
        return _handle_exam_hall_phase("enter")
    elif (now < start_dt or now > end_dt) and active:
        return _handle_exam_hall_phase("exit")
    else:
        return []

# ------------------ SIMPLE FAST LOOP FOR DEMO ------------------

def simulate_telemetry_scenario(scenario: str) -> None:
    """
    Modify TELEMETRY to represent a hypothetical scenario:
      - 'normal'
      - 'exam_rush'
      - 'exam_interference'
    """
    global TELEMETRY

    if scenario == "normal":
        for ap_id in AP_IDS:
            TELEMETRY[ap_id]["num_clients"] = random.randint(3, 10)
            TELEMETRY[ap_id]["interference"] = False

    elif scenario == "exam_rush":
        for ap_id in AP_IDS:
            if ap_id.startswith("ap_exam"):
                TELEMETRY[ap_id]["num_clients"] = random.randint(30, 50)
            elif "corridor" in ap_id:
                TELEMETRY[ap_id]["num_clients"] = random.randint(5, 15)
            else:
                TELEMETRY[ap_id]["num_clients"] = random.randint(0, 5)
            TELEMETRY[ap_id]["interference"] = False

    elif scenario == "exam_interference":
        for ap_id in AP_IDS:
            if ap_id.startswith("ap_exam"):
                TELEMETRY[ap_id]["num_clients"] = random.randint(25, 40)
                TELEMETRY[ap_id]["interference"] = True
            else:
                TELEMETRY[ap_id]["num_clients"] = random.randint(5, 15)
                TELEMETRY[ap_id]["interference"] = False

    else:
        # unknown scenario, default to normal
        for ap_id in AP_IDS:
            TELEMETRY[ap_id]["num_clients"] = random.randint(3, 10)
            TELEMETRY[ap_id]["interference"] = False


def fast_loop_step() -> List[Dict[str, Any]]:
    """
    Very simplified fast-loop:
      - If interference and bandwidth > 20 -> propose width=20
      - If interference and bandwidth == 20 and NOT exam AP under exam mode -> propose simple channel change
    """
    proposals: List[Dict[str, Any]] = []

    for ap_id in AP_IDS:
        tel = TELEMETRY[ap_id]
        cfg = AP_BASELINE_CONFIG[ap_id]
        interference = tel["interference"]
        cur_bw = cfg["bandwidth"]
        cur_ch = cfg["channel"]

        # If exam is active and this is an exam AP, be conservative: only allow width tighten (no channel changes)
        is_exam_ap_active = EXAM_HALL_STATE["active"] and (ap_id in EXAM_HALL_STATE["exam_aps"])

        if interference:
            if cur_bw > 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "FASTLOOP_INTERFERENCE_WIDTH_TIGHTEN",
                })
                cfg["bandwidth"] = 20
            else:
                if not is_exam_ap_active:
                    # Quick and dirty "channel change": hop to a different channel in {1,6,11,36}
                    candidate_channels = [1, 6, 11, 36]
                    next_ch = candidate_channels[(candidate_channels.index(cur_ch) + 1) % len(candidate_channels)] \
                        if cur_ch in candidate_channels else candidate_channels[0]
                    if next_ch != cur_ch:
                        proposals.append({
                            "ap_id": ap_id,
                            "type": "channel",
                            "value": next_ch,
                            "reason": "FASTLOOP_INTERFERENCE_CHANNEL_HOP",
                        })
                        cfg["channel"] = next_ch
                        TELEMETRY[ap_id]["channel"] = next_ch

    return proposals

# ------------------ APPLY PROPOSALS + CONTROL STEP ------------------

def apply_proposals(proposals: List[Dict[str, Any]]) -> None:
    """
    Apply proposals to AP_BASELINE_CONFIG + TELEMETRY.
    """
    global AP_BASELINE_CONFIG, TELEMETRY

    for p in proposals:
        ap_id = p["ap_id"]
        ptype = p["type"]
        value = p["value"]

        if ap_id not in AP_BASELINE_CONFIG:
            continue

        if ptype in ("channel", "bandwidth", "txpower", "fast_loop_mode"):
            AP_BASELINE_CONFIG[ap_id][ptype] = value
            if ptype in ("channel", "bandwidth", "txpower"):
                TELEMETRY[ap_id][ptype] = value


def control_step(sim_date_str: str, sim_time_str: str, scenario: str) -> tuple:
    """
    Main "slow loop + fast loop + event loop" control step used by the GUI.
    1. Parses simulated 'now'
    2. Sets telemetry for 'scenario'
    3. Runs exam_hall_event_tick(now) -> event proposals
    4. Runs fast_loop_step() -> fast-loop proposals
    5. Applies both and returns log + current config + telemetry.
    """
    # Parse date/time
    try:
        sim_date = datetime.strptime(sim_date_str, "%Y-%m-%d").date()
    except ValueError:
        return "âŒ Invalid date (use YYYY-MM-DD).", {}, {}, {}

    try:
        sim_time = datetime.strptime(sim_time_str, "%H:%M").time()
    except ValueError:
        return "âŒ Invalid time (use HH:MM).", {}, {}, {}

    now = datetime.combine(sim_date, sim_time)

    # 1) simulate telemetry
    simulate_telemetry_scenario(scenario)

    # 2) event loop (exam hall)
    event_props = exam_hall_event_tick(now)

    # 3) fast loop
    fast_props = fast_loop_step()

    all_props = event_props + fast_props
    apply_proposals(all_props)

    # Simple human-readable log
    lines = []
    lines.append(f"Simulated now = {now.isoformat(' ', 'seconds')}")
    lines.append(f"Scenario      = {scenario}")
    lines.append(f"Exam active   = {EXAM_HALL_STATE['active']}")

    if not all_props:
        lines.append("No proposals generated.")
    else:
        lines.append("Proposals:")
        for p in all_props:
            lines.append(f"  - {p['ap_id']}: {p['type']} -> {p['value']} ({p['reason']})")

    log = "\n".join(lines)

    return (
        log,
        AP_BASELINE_CONFIG,
        TELEMETRY,
        all_props,
    )

# Initialize clean state once
reset_simulation_state()

from datetime import date, datetime

today_str = date.today().strftime("%Y-%m-%d")

# ---------- Helper: render AP cards as HTML ----------

def build_ap_cards_html(cfg: Dict[str, Dict[str, Any]],
                        tel: Dict[str, Dict[str, Any]]) -> str:
    """
    Build a small HTML 'dashboard' of AP cards:
    - shows role, channel, bandwidth, txpower, clients, interference, exam-status
    """
    def ap_role(ap_id: str) -> str:
        if "exam" in ap_id:
            return "Exam hall"
        if "corridor" in ap_id:
            return "Near exam"
        if "canteen" in ap_id:
            return "Canteen"
        return "Other"

    exam_active = EXAM_HALL_STATE["active"]
    exam_aps = EXAM_HALL_STATE["exam_aps"]
    neighbor_aps = EXAM_HALL_STATE["neighbor_aps"]

    card_htmls = []
    for ap_id in AP_IDS:
        c = cfg[ap_id]
        t = tel[ap_id]
        role = ap_role(ap_id)

        is_exam = ap_id in exam_aps
        is_neigh = ap_id in neighbor_aps
        clients = t.get("num_clients", 0)
        interf = t.get("interference", False)

        if exam_active and is_exam:
            border = "#22c55e"  # green
            bg = "#ecfdf3"
            label = "Exam AP (ACTIVE)"
        elif exam_active and is_neigh:
            border = "#eab308"  # amber
            bg = "#fffbeb"
            label = "Neighbor (ACTIVE)"
        else:
            border = "#e5e7eb"
            bg = "#f9fafb"
            label = role

        interfer_str = "Yes" if interf else "No"
        interfer_color = "#ef4444" if interf else "#22c55e"

        card_html = f"""
        <div style="
            flex: 1 1 220px;
            border: 2px solid {border};
            border-radius: 0.75rem;
            padding: 0.75rem 0.9rem;
            margin: 0.4rem;
            background: {bg};
            font-size: 0.85rem;
            box-shadow: 0 4px 10px rgba(15,23,42,0.06);
        ">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.3rem;">
            <div style="font-weight:600;">{ap_id}</div>
            <span style="font-size:0.75rem;color:#4b5563;">{label}</span>
          </div>
          <div style="display:flex;flex-wrap:wrap;column-gap:0.75rem;row-gap:0.15rem;margin-bottom:0.35rem;">
            <div>ðŸ“¡ <b>Ch</b> {c.get('channel', '-')}</div>
            <div> <b>BW</b> {c.get('bandwidth', '-')} MHz</div>
            <div>âš¡ <b>P</b> {c.get('txpower', '-')} dBm</div>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>ðŸ‘¥ Clients: <b>{clients}</b></div>
            <div> Interf:
              <span style="color:{interfer_color};font-weight:600;">{interfer_str}</span>
            </div>
          </div>
        </div>
        """
        card_htmls.append(card_html)

    html = """
    <div style="display:flex;flex-wrap:wrap;justify-content:flex-start;">
    """ + "\n".join(card_htmls) + "</div>"
    return html


# ---------- Helper: exam timeline indicator ----------

def build_timeline_html(sim_date_str: str, sim_time_str: str) -> str:
    """
    Render a tiny timeline against the latest exam schedule and the simulated time.
    """
    try:
        sim_date = datetime.strptime(sim_date_str, "%Y-%m-%d").date()
        sim_time = datetime.strptime(sim_time_str, "%H:%M").time()
        now_dt = datetime.combine(sim_date, sim_time)
    except Exception:
        return (
            "<div style='font-size:0.85rem;color:#ef4444;'>"
            "Could not parse simulated date/time for timeline."
            "</div>"
        )

    schedules = [s for s in load_schedules() if s.get("type") == "EXAM_HALL_QUIET_HOURS"]
    if not schedules:
        return (
            "<div style='font-size:0.85rem;color:#6b7280;'>"
            "No exam schedule defined yet. Create one in the <b>Schedule</b> tab."
            "</div>"
        )

    sched = schedules[-1]  # latest
    exam_date = datetime.strptime(sched["date"], "%Y-%m-%d").date()
    start_t = datetime.strptime(sched["start_time"], "%H:%M:%S").time()
    end_t = datetime.strptime(sched["end_time"], "%H:%M:%S").time()
    start_dt = datetime.combine(exam_date, start_t)
    end_dt = datetime.combine(exam_date, end_t)

    if now_dt < start_dt:
        status = "Before exam window"
        color = "#0ea5e9"
    elif start_dt <= now_dt <= end_dt:
        status = "Inside exam window"
        color = "#22c55e"
    else:
        status = "After exam window"
        color = "#6b7280"

    total = (end_dt - start_dt).total_seconds() or 1
    if now_dt <= start_dt:
        pct = 0
    elif now_dt >= end_dt:
        pct = 100
    else:
        pct = int(((now_dt - start_dt).total_seconds() / total) * 100)

    html = f"""
    <div style="font-size:0.85rem;margin-top:0.4rem;">
      <div><b>Exam window:</b> {sched['date']} {start_t.strftime('%H:%M')}â€“{end_t.strftime('%H:%M')}</div>
      <div><b>Simulated time:</b> {now_dt.strftime('%Y-%m-%d %H:%M')}</div>
      <div style="margin:0.3rem 0 0.15rem 0;"><b>Status:</b> <span style="color:{color};">{status}</span></div>
      <div style="position:relative;height:8px;border-radius:999px;background:#e5e7eb;overflow:hidden;margin-top:0.25rem;">
        <div style="width:{pct}%;height:100%;background:{color};"></div>
      </div>
      <div style="text-align:right;font-size:0.75rem;color:#6b7280;margin-top:0.1rem;">
        {pct}% of exam window elapsed
      </div>
    </div>
    """
    return html


# ---------- Wrapper to plug into UI ----------

def control_step_ui(sim_date_str: str, sim_time_str: str, scenario: str):
    """
    Wraps control_step to also build AP cards & timeline for the UI.
    """
    log, cfg, tel, props = control_step(sim_date_str, sim_time_str, scenario)
    cards_html = ""
    timeline_html = ""
    if cfg and tel:
        cards_html = build_ap_cards_html(cfg, tel)
        timeline_html = build_timeline_html(sim_date_str, sim_time_str)
    return log, cfg, tel, props, cards_html, timeline_html


# ---------- Enhanced Gradio UI ----------

with gr.Blocks(
    title="RRM Proof-of-Concept Simulator",
    theme=gr.themes.Soft(primary_hue="blue", secondary_hue="slate"),
) as demo:
    # ----- HEADER -----
    gr.HTML(
        """
        <div style="text-align:center; padding: 0.5rem 0 1.0rem 0;">
          <h1 style="margin-bottom:0.3rem;">ðŸ“¡ RRM Control & Exam Hall Simulator</h1>
          <p style="font-size:0.95rem; color:#555; max-width:680px; margin: 0 auto;">
            End-to-end proof-of-concept for an event-loop driven RRM controller.
            Schedule <b>Exam Hall Quiet Hours</b>, adjust guardrails, and step through the
            <b>event loop + fast loop</b> on realistic scenarios.
          </p>
        </div>
        """
    )

    with gr.Tabs():
        # ================= TAB 1: SCHEDULER =================
        with gr.Tab("1ï¸âƒ£ Schedule Exam Quiet Hours"):
            gr.Markdown(
                """
                ### ðŸŽ“ Exam Hall Quiet Hours

                Define when the exam hall should be in a **strict, stable** configuration
                with power shaping and fast-loop guardrails.

                **Workflow**
                1. Pick the **exam date** and **time window**
                2. Choose which APs are inside the hall and which are neighbors
                3. Tune power / stability knobs
                4. Click **Add Exam Hall Schedule**
                """
            )

            with gr.Row():
                with gr.Column():
                    with gr.Accordion("ðŸ—“ï¸ Exam window", open=True):
                        exam_date = gr.Textbox(
                            label="Exam date (YYYY-MM-DD)",
                            value=today_str,
                            placeholder="2025-12-04",
                        )
                        with gr.Row():
                            start_time = gr.Textbox(
                                label="Start time (HH:MM)",
                                value="09:00",
                                placeholder="09:00",
                            )
                            end_time = gr.Textbox(
                                label="End time (HH:MM)",
                                value="12:00",
                                placeholder="12:00",
                            )

                with gr.Column():
                    with gr.Accordion("ðŸ“¡ AP selection", open=True):
                        gr.Markdown(
                            """
                            **Topology (demo):**
                            - `ap_exam_1`, `ap_exam_2` â†’ inside exam hall
                            - `ap_corridor_1`, `ap_corridor_2` â†’ near exam hall
                            - `ap_canteen` â†’ far away (canteen)
                            """
                        )
                        exam_aps_text = gr.Textbox(
                            label="Exam hall AP IDs (comma-separated)",
                            value="ap_exam_1, ap_exam_2",
                            placeholder="ap_exam_1, ap_exam_2",
                        )
                        neighbor_aps_text = gr.Textbox(
                            label="Neighbor AP IDs (optional, comma-separated)",
                            value="ap_corridor_1, ap_corridor_2",
                            placeholder="ap_corridor_1, ap_corridor_2",
                        )

            with gr.Accordion("âš™ï¸ Policy knobs for exam hall", open=False):
                gr.Markdown(
                    """
                    These knobs define the **event-loop policy** during the exam:

                    - **Exam AP power boost** â†’ make exam APs slightly louder
                    - **Neighbor power reduction** â†’ shrink corridor cells
                    - **Force 20 MHz** â†’ stable but narrower channels
                    - **Conservative fast-loop mode** â†’ avoid jittery changes mid-exam
                    """
                )
                with gr.Row():
                    power_boost_db = gr.Slider(
                        label="Exam AP power boost (dB)",
                        minimum=0,
                        maximum=6,
                        step=1,
                        value=3,
                    )
                    power_reduce_db = gr.Slider(
                        label="Neighbor AP power reduction (dB)",
                        minimum=0,
                        maximum=6,
                        step=1,
                        value=3,
                    )
                with gr.Row():
                    force_20_mhz = gr.Checkbox(
                        label="Force 20 MHz during exam", value=True
                    )
                    conservative_mode = gr.Checkbox(
                        label="Conservative fast-loop mode", value=True
                    )

            gr.Markdown("---")

            with gr.Row():
                schedule_btn = gr.Button(
                    "âœ… Add Exam Hall Schedule",
                    variant="primary",
                    scale=2,
                )
                clear_sched_btn = gr.Button(
                    "ðŸ§¹ Clear all schedules",
                    variant="secondary",
                )

            status_out = gr.Markdown()
            created_json = gr.JSON(label="Last created schedule entry")

            schedule_btn.click(
                fn=schedule_exam_entry,
                inputs=[
                    exam_date,
                    start_time,
                    end_time,
                    exam_aps_text,
                    neighbor_aps_text,
                    power_boost_db,
                    power_reduce_db,
                    force_20_mhz,
                    conservative_mode,
                ],
                outputs=[status_out, created_json],
            )

            def clear_schedules():
                save_schedules([])
                return "ðŸ§¹ Cleared all exam schedules.", {"schedules": []}

            gr.Markdown("### ðŸ“‚ Existing schedules (exam_schedules.json)")
            view_btn = gr.Button(" Refresh schedules")
            schedules_json = gr.JSON(label="All schedule entries")

            view_btn.click(fn=view_schedules, inputs=None, outputs=schedules_json)
            clear_sched_btn.click(
                fn=clear_schedules,
                inputs=None,
                outputs=[status_out, schedules_json],
            )

        # ================= TAB 2: SIMULATION =================
        with gr.Tab("2ï¸âƒ£ Run Simulation"):
            gr.Markdown(
                """
                ### ðŸ§ª Run RRM Control Step

                Simulate a **single control step** of your controller:

                1. Choose a simulated **time** and **scenario**
                2. Controller:
                   - sets telemetry for the scenario
                   - runs the **exam-hall event loop**
                   - runs a simple **fast loop**
                   - applies all proposals
                3. You see:
                   - the controller log
                   - updated AP configs
                   - AP cards
                   - updated telemetry
                   - proposals applied
                """
            )

            with gr.Accordion(" Campus topology (fixed for demo)", open=False):
                gr.Markdown(
                    """
                    | AP ID           | Role               | Default channel | Default BW | Default power |
                    |-----------------|--------------------|-----------------|------------|---------------|
                    | `ap_exam_1`     | Exam hall          | 1               | 40 MHz     | 15 dBm        |
                    | `ap_exam_2`     | Exam hall          | 6               | 40 MHz     | 15 dBm        |
                    | `ap_corridor_1` | Near exam hall     | 1               | 40 MHz     | 17 dBm        |
                    | `ap_corridor_2` | Near exam hall     | 11              | 40 MHz     | 17 dBm        |
                    | `ap_canteen`    | Canteen            | 36              | 40 MHz     | 20 dBm        |
                    """
                )

            with gr.Row():
                sim_date = gr.Textbox(
                    label="Simulated date (YYYY-MM-DD)",
                    value=today_str,
                    scale=1,
                )
                sim_time = gr.Textbox(
                    label="Simulated time (HH:MM)",
                    value="09:30",
                    scale=1,
                )

            scenario = gr.Radio(
                label="Scenario",
                choices=[
                    "normal",
                    "exam_rush",
                    "exam_interference",
                ],
                value="exam_rush",
                interactive=True,
            )

            with gr.Row():
                run_btn = gr.Button(
                    " Run one control step",
                    variant="primary",
                    scale=2,
                )
                reset_btn = gr.Button(
                    "â™»ï¸ Reset simulation state",
                    variant="secondary",
                )

            with gr.Row():
                with gr.Column(scale=2):
                    log_out = gr.Textbox(
                        label="Controller log",
                        lines=12,
                        show_label=True,
                    )
                    timeline_html = gr.HTML(label="Exam timeline")

                with gr.Column(scale=3):
                    ap_cards_html = gr.HTML(label="AP overview")

            cfg_out = gr.JSON(label="AP_BASELINE_CONFIG after step")
            tel_out = gr.JSON(label="TELEMETRY after step")
            props_out = gr.JSON(label="Proposals applied (event loop + fast loop)")

            run_btn.click(
                fn=control_step_ui,
                inputs=[sim_date, sim_time, scenario],
                outputs=[log_out, cfg_out, tel_out, props_out, ap_cards_html, timeline_html],
            )

            def reset_and_report():
                reset_simulation_state()
                return "âœ… Simulation state reset to initial AP configs and telemetry."

            reset_status = gr.Markdown()
            reset_btn.click(fn=reset_and_report, inputs=None, outputs=reset_status)

demo.launch()

# ================== RF / Spectrum Events (RF-1 .. RF-5) ==================
from typing import List, Dict, Any, Set

# Keep a tiny bit of RF state for PoC
RF_STATE: Dict[str, Any] = {
    # Channels we want to avoid (e.g. persistent non-Wi-Fi, DFS cluster)
    "avoid_channels": set(),   # Set[int]
    # Channels with recent DFS radar hits
    "dfs_banned_channels": set(),  # Set[int]
}

# Simple candidate list for our tiny campus PoC
RF_CANDIDATE_CHANNELS = [1, 6, 11, 36]


def _rf_pick_clean_channel(current_ch: int,
                           avoid_channels: Set[int]) -> int:
    """
    Pick a 'clean' channel from RF_CANDIDATE_CHANNELS avoiding avoid_channels.
    Falls back to any candidate if all are avoided.
    """
    # First pass: avoid channels we don't like
    for ch in RF_CANDIDATE_CHANNELS:
        if ch != current_ch and ch not in avoid_channels:
            return ch

    # Second pass: just pick something different from current
    for ch in RF_CANDIDATE_CHANNELS:
        if ch != current_ch:
            return ch

    # Last resort: stay on current
    return current_ch


def handle_rf_event(event_code: str,
                    affected_aps: List[str],
                    meta: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    """
    RF / Spectrum event dispatcher.

    event_code:
      - "RF-1" NON_WIFI_BURST
      - "RF-2" NON_WIFI_PERSISTENT
      - "RF-3" DFS_RADAR_HIT
      - "RF-4" DFS_RADAR_CLUSTER
      - "RF-5" OBSS_INTERFERENCE_SPIKE

    affected_aps: AP IDs that are impacted by the event.
    meta: extra info from detectors (e.g. interfered_channel, dfs_channel, etc.).

    Returns: list of proposals.
    """
    if meta is None:
        meta = {}

    proposals: List[Dict[str, Any]] = []

    # Handy local alias
    avoid_channels: Set[int] = RF_STATE["avoid_channels"]
    dfs_banned: Set[int] = RF_STATE["dfs_banned_channels"]

    # ------------ RF-1 NON_WIFI_BURST ------------
    # Short-lived non-Wi-Fi interference (microwave, BLE etc.).
    # Actions:
    #   - For affected APs on interfered channel: shrink BW to 20 MHz, hop off channel
    #   - Do NOT globally ban channel yet (TTL is short)
    if event_code == "RF-1":
        interfered_ch = meta.get("interfered_channel")
        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})
            cur_ch = cfg.get("channel")
            cur_bw = cfg.get("bandwidth", 20)

            if interfered_ch is not None and cur_ch != interfered_ch:
                # Not on the noisy channel; skip
                continue

            # 1) Shrink bandwidth to 20 MHz
            if cur_bw > 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "RF-1_NON_WIFI_BURST_SHRINK_BW",
                })
                cfg["bandwidth"] = 20
                tel["bandwidth"] = 20

            # 2) Channel hop to nearest clean channel (local, not global ban)
            new_ch = _rf_pick_clean_channel(cur_ch, avoid_channels=set())
            if new_ch != cur_ch:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "channel",
                    "value": new_ch,
                    "reason": "RF-1_NON_WIFI_BURST_CHANNEL_HOP",
                })
                cfg["channel"] = new_ch
                tel["channel"] = new_ch

        return proposals

    # ------------ RF-2 NON_WIFI_PERSISTENT ------------
    # Persistent non-Wi-Fi occupancy / interference.
    # Actions:
    #   - Same as RF-1 (BW shrink + hop)
    #   - Additionally add interfered channel to RF_STATE["avoid_channels"]
    if event_code == "RF-2":
        interfered_ch = meta.get("interfered_channel")
        if interfered_ch is not None:
            avoid_channels.add(interfered_ch)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})
            cur_ch = cfg.get("channel")
            cur_bw = cfg.get("bandwidth", 20)

            if interfered_ch is not None and cur_ch != interfered_ch:
                continue

            if cur_bw > 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "RF-2_NON_WIFI_PERSISTENT_SHRINK_BW",
                })
                cfg["bandwidth"] = 20
                tel["bandwidth"] = 20

            new_ch = _rf_pick_clean_channel(cur_ch, avoid_channels=avoid_channels)
            if new_ch != cur_ch:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "channel",
                    "value": new_ch,
                    "reason": "RF-2_NON_WIFI_PERSISTENT_CHANNEL_HOP",
                })
                cfg["channel"] = new_ch
                tel["channel"] = new_ch

        return proposals

    # ------------ RF-3 DFS_RADAR_HIT ------------
    # Single AP DFS radar hit: must vacate channel immediately.
    # Actions:
    #   - Move that AP to a non-DFS channel (or any allowed safe channel).
    if event_code == "RF-3":
        dfs_channel = meta.get("dfs_channel")  # optional; else we use AP's channel
        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})
            cur_ch = cfg.get("channel")
            radar_ch = dfs_channel or cur_ch

            # For PoC, just treat 'radar_ch' as banned for this AP
            dfs_banned.add(radar_ch)
            new_ch = _rf_pick_clean_channel(cur_ch, avoid_channels=dfs_banned | avoid_channels)
            if new_ch != cur_ch:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "channel",
                    "value": new_ch,
                    "reason": "RF-3_DFS_RADAR_HIT_MOVE_TO_NON_DFS",
                })
                cfg["channel"] = new_ch
                tel["channel"] = new_ch

        return proposals

    # ------------ RF-4 DFS_RADAR_CLUSTER ------------
    # Multiple DFS hits in the same channel / region.
    # Actions:
    #   - Move all impacted APs off that channel
    #   - Globally ban that channel (RF_STATE["dfs_banned_channels"])
    if event_code == "RF-4":
        cluster_channel = meta.get("cluster_channel")
        if cluster_channel is not None:
            dfs_banned.add(cluster_channel)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})
            cur_ch = cfg.get("channel")

            if cluster_channel is not None and cur_ch != cluster_channel:
                continue

            new_ch = _rf_pick_clean_channel(cur_ch, avoid_channels=dfs_banned | avoid_channels)
            if new_ch != cur_ch:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "channel",
                    "value": new_ch,
                    "reason": "RF-4_DFS_RADAR_CLUSTER_MOVE",
                })
                cfg["channel"] = new_ch
                tel["channel"] = new_ch

        return proposals

    # ------------ RF-5 OBSS_INTERFERENCE_SPIKE ------------
    # OBSS / hidden node causing high CCA busy & retries.
    # Actions:
    #   - Increase OBSS-PD offset (less sensitive to neighbors)
    #   - Reduce width to 20 MHz
    #   - Optionally reduce TX power a bit to shrink cell
    if event_code == "RF-5":
        delta_obss_pd = meta.get("delta_obss_pd", +4)  # dB
        power_delta = meta.get("power_delta", -2)      # dB
        min_power_dbm = meta.get("min_power_dbm", 5.0)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})

            # 1) OBSS-PD offset
            old_pd = float(cfg.get("obss_pd_offset", 0.0))
            new_pd = old_pd + delta_obss_pd
            proposals.append({
                "ap_id": ap_id,
                "type": "obss_pd_offset",
                "value": new_pd,
                "reason": "RF-5_OBSS_INTERFERENCE_SPIKE_PD_ADJUST",
            })
            cfg["obss_pd_offset"] = new_pd

            # 2) BW -> 20 MHz
            if cfg.get("bandwidth", 20) > 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "RF-5_OBSS_INTERFERENCE_SPIKE_SHRINK_BW",
                })
                cfg["bandwidth"] = 20
                tel["bandwidth"] = 20

            # 3) Small power reduction (shrink interference domain)
            old_pwr = float(cfg.get("txpower", 15.0))
            new_pwr = max(old_pwr + power_delta, min_power_dbm)
            if new_pwr != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": new_pwr,
                    "reason": "RF-5_OBSS_INTERFERENCE_SPIKE_POWER_REDUCE",
                })
                cfg["txpower"] = new_pwr
                tel["txpower"] = new_pwr

        return proposals

    # Unknown code -> no-op
    return []

# ================== QoE Events (QOE-1 .. QOE-4) ==================
from typing import List, Dict, Any

QOE_STATE: Dict[str, Any] = {
    # Cells we have tagged as "needs slow-loop reoptimization"
    "needs_reoptimize": set(),  # Set[ap_id]
}


def handle_qoe_event(event_code: str,
                     affected_aps: List[str],
                     meta: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    """
    QoE event dispatcher.

    event_code:
      - "QOE-1" QOE_COLLAPSE_LOCAL
      - "QOE-2" QOE_DEGRADATION_PERSISTENT
      - "QOE-3" EDGE_CLIENT_RTT_SPIKE
      - "QOE-4" HIGH_LOAD_HOTSPOT

    affected_aps: APs whose QoE KPIs are bad.
    meta: optional info from KPI pipeline (severity, load, etc.).
    """
    if meta is None:
        meta = {}

    proposals: List[Dict[str, Any]] = []
    needs_reopt = QOE_STATE["needs_reoptimize"]

    # ------------ QOE-1 QOE_COLLAPSE_LOCAL ------------
    # Severe local QoE collapse.
    # Actions:
    #   - Force BW = 20 MHz
    #   - Increase OBSS-PD offset (less contention)
    #   - (Optionally) mark for slow-loop reoptimization
    if event_code == "QOE-1":
        delta_obss_pd = meta.get("delta_obss_pd", +4)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})

            if cfg.get("bandwidth", 20) > 20:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": 20,
                    "reason": "QOE-1_COLLAPSE_FORCE_20MHZ",
                })
                cfg["bandwidth"] = 20
                tel["bandwidth"] = 20

            old_pd = float(cfg.get("obss_pd_offset", 0.0))
            new_pd = old_pd + delta_obss_pd
            proposals.append({
                "ap_id": ap_id,
                "type": "obss_pd_offset",
                "value": new_pd,
                "reason": "QOE-1_COLLAPSE_PD_INCREASE",
            })
            cfg["obss_pd_offset"] = new_pd

            needs_reopt.add(ap_id)

        return proposals

    # ------------ QOE-2 QOE_DEGRADATION_PERSISTENT ------------
    # Slow, long-lasting QoE decay.
    # Actions:
    #   - Mild OBSS-PD increase
    #   - Slight TX power reduction
    #   - Mark APs for slow-loop global reoptimization
    if event_code == "QOE-2":
        delta_obss_pd = meta.get("delta_obss_pd", +2)
        power_delta = meta.get("power_delta", -1)
        min_power_dbm = meta.get("min_power_dbm", 5.0)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})

            # OBSS-PD
            old_pd = float(cfg.get("obss_pd_offset", 0.0))
            new_pd = old_pd + delta_obss_pd
            proposals.append({
                "ap_id": ap_id,
                "type": "obss_pd_offset",
                "value": new_pd,
                "reason": "QOE-2_DEGRADATION_PD_MILD_INCREASE",
            })
            cfg["obss_pd_offset"] = new_pd

            # Slight power reduction
            old_pwr = float(cfg.get("txpower", 15.0))
            new_pwr = max(old_pwr + power_delta, min_power_dbm)
            if new_pwr != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": new_pwr,
                    "reason": "QOE-2_DEGRADATION_POWER_REDUCE",
                })
                cfg["txpower"] = new_pwr
                tel["txpower"] = new_pwr

            needs_reopt.add(ap_id)

        return proposals

    # ------------ QOE-3 EDGE_CLIENT_RTT_SPIKE ------------
    # One or more edge clients with very high RTT.
    # Actions (PoC):
    #   - Slight TX power increase (to reach edge)
    #   - Make fast-loop more conservative (less jitter for edge clients)
    if event_code == "QOE-3":
        power_delta = meta.get("power_delta", +2)
        max_power_dbm = meta.get("max_power_dbm", 22.0)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue

            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})

            old_pwr = float(cfg.get("txpower", 15.0))
            new_pwr = min(old_pwr + power_delta, max_power_dbm)
            if new_pwr != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": new_pwr,
                    "reason": "QOE-3_EDGE_RTT_POWER_BOOST",
                })
                cfg["txpower"] = new_pwr
                tel["txpower"] = new_pwr

            # Make fast loop conservative so it doesn't keep hopping
            if cfg.get("fast_loop_mode") != "conservative":
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": "conservative",
                    "reason": "QOE-3_EDGE_RTT_CONSERVATIVE_FAST_LOOP",
                })
                cfg["fast_loop_mode"] = "conservative"

        return proposals

    # ------------ QOE-4 HIGH_LOAD_HOTSPOT ------------
    # Unexpected crowd causing AP overload (canteen, large gathering).
    # Actions:
    #   - Reduce bandwidth (80 -> 40/20) for stability
    #   - Slight power reduction to encourage offload to neighbors
    #   - Optionally mark cell as 'hotspot' for slow-loop
    if event_code == "QOE-4":
        power_delta = meta.get("power_delta", -2)
        min_power_dbm = meta.get("min_power_dbm", 5.0)

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            tel = TELEMETRY.get(ap_id, {})

            # Bandwidth
            bw = cfg.get("bandwidth", 40)
            if bw > 40:
                new_bw = 40
            elif bw > 20:
                new_bw = 20
            else:
                new_bw = bw

            if new_bw != bw:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": new_bw,
                    "reason": "QOE-4_HIGH_LOAD_SHRINK_BW",
                })
                cfg["bandwidth"] = new_bw
                tel["bandwidth"] = new_bw

            # Power reduction to push clients to neighbors if possible
            old_pwr = float(cfg.get("txpower", 15.0))
            new_pwr = max(old_pwr + power_delta, min_power_dbm)
            if new_pwr != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": new_pwr,
                    "reason": "QOE-4_HIGH_LOAD_POWER_REDUCE",
                })
                cfg["txpower"] = new_pwr
                tel["txpower"] = new_pwr

            needs_reopt.add(ap_id)

        return proposals

    return []

# ================== Scheduled Events (SCH-2 .. SCH-4) ==================
from typing import List, Dict, Any
from datetime import datetime, time as dtime

# Simple state for scheduled modes (separate from EXAM_HALL_STATE)
LECTURE_HALL_STATE: Dict[str, Any] = {
    "active": False,
    "aps": set(),
    "backup": {},
}

NIGHT_MAINT_STATE: Dict[str, Any] = {
    "active": False,
}

PEAK_HOURS_STATE: Dict[str, Any] = {
    "active": False,
}


def handle_lecture_hall_event(phase: str,
                              aps: List[str]) -> List[Dict[str, Any]]:
    """
    SCH-2 LECTURE_HALL_MODE
    - High-density predictable load.
    - Actions (enter):
      - Prefer 20/40 MHz
      - Slight TX power reduction (increase spatial reuse)
      - Mark fast_loop_mode = 'normal' (not super conservative, not too aggressive)
    - Exit: restore previous config for those APs.
    """
    proposals: List[Dict[str, Any]] = []
    st = LECTURE_HALL_STATE

    if phase == "enter":
        if st["active"]:
            return proposals

        st["active"] = True
        st["aps"] = set(aps)
        st["backup"] = {}

        for ap_id in aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            st["backup"][ap_id] = deepcopy(cfg)

            # Bandwidth: limit to 40 MHz max
            bw = cfg.get("bandwidth", 40)
            new_bw = 40 if bw > 40 else bw
            if new_bw != bw:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "bandwidth",
                    "value": new_bw,
                    "reason": "SCH-2_LECTURE_ENTER_CAP_BW_40MHZ",
                })
                cfg["bandwidth"] = new_bw

            # Slight power reduction to increase spatial reuse
            old_pwr = float(cfg.get("txpower", 15.0))
            new_pwr = max(old_pwr - 1.0, 5.0)
            if new_pwr != old_pwr:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "txpower",
                    "value": new_pwr,
                    "reason": "SCH-2_LECTURE_ENTER_POWER_REDUCE",
                })
                cfg["txpower"] = new_pwr

            # Ensure fast_loop_mode is normal (no exam-like constraints)
            if cfg.get("fast_loop_mode") != "normal":
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": "normal",
                    "reason": "SCH-2_LECTURE_ENTER_FAST_LOOP_NORMAL",
                })
                cfg["fast_loop_mode"] = "normal"

        return proposals

    elif phase == "exit":
        if not st["active"]:
            return proposals

        st["active"] = False
        for ap_id, prev_cfg in st["backup"].items():
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cur = AP_BASELINE_CONFIG[ap_id]
            for field in ("bandwidth", "txpower", "fast_loop_mode"):
                if field in prev_cfg and cur.get(field) != prev_cfg[field]:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": field,
                        "value": prev_cfg[field],
                        "reason": "SCH-2_LECTURE_EXIT_RESTORE",
                    })
                    cur[field] = prev_cfg[field]

        st["aps"] = set()
        st["backup"] = {}
        return proposals

    else:
        raise ValueError(f"Unknown lecture hall phase {phase}")


def handle_night_maintenance_window(active: bool) -> List[Dict[str, Any]]:
    """
    SCH-3 NIGHT_MAINTENANCE_WINDOW
    - When active:
      - We can relax guardrails a bit and allow more aggressive tuning.
      - For PoC:
        - Set fast_loop_mode = 'aggressive' on all APs.
    - When inactive:
      - Restore fast_loop_mode = 'normal' (unless exam/lecture overrides).
    """
    proposals: List[Dict[str, Any]] = []
    st = NIGHT_MAINT_STATE

    if active and not st["active"]:
        st["active"] = True
        for ap_id, cfg in AP_BASELINE_CONFIG.items():
            if cfg.get("fast_loop_mode") != "aggressive":
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": "aggressive",
                    "reason": "SCH-3_NIGHT_MAINT_ENTER_FAST_LOOP_AGGRESSIVE",
                })
                cfg["fast_loop_mode"] = "aggressive"

    elif not active and st["active"]:
        st["active"] = False
        for ap_id, cfg in AP_BASELINE_CONFIG.items():
            if cfg.get("fast_loop_mode") == "aggressive":
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": "normal",
                    "reason": "SCH-3_NIGHT_MAINT_EXIT_FAST_LOOP_NORMAL",
                })
                cfg["fast_loop_mode"] = "normal"

    return proposals


def handle_daily_peak_hours_block(active: bool) -> List[Dict[str, Any]]:
    """
    SCH-4 DAILY_PEAK_HOURS_BLOCK
    - During daily peak hours we want to block risky changes from non-incident events.
    - For PoC:
      - Just flip a state flag that your planner / apply_proposals can consult.
      - We won't generate per-AP proposals here, but we surface the state.
    """
    st = PEAK_HOURS_STATE
    proposals: List[Dict[str, Any]] = []

    if active and not st["active"]:
        st["active"] = True
    elif not active and st["active"]:
        st["active"] = False

    # NOTE: In your apply_proposals() or planner, you can read
    #   PEAK_HOURS_STATE["active"] and refuse non-incident changes
    #   when True. For PoC we keep it as a pure state flag.
    return proposals


# Example helper to drive SCH-2..4 from a scheduler / slow loop
def scheduled_events_tick(now: datetime,
                          lecture_windows: Dict[str, Dict[str, dtime]] | None = None,
                          night_window: Dict[str, dtime] | None = None,
                          peak_window: Dict[str, dtime] | None = None) -> List[Dict[str, Any]]:
    """
    Example periodic tick for scheduled events (except exam, which you already have):
      - lecture_windows: map of 'site' or 'room' -> {"start": time, "end": time}
      - night_window: {"start": time, "end": time}
      - peak_window: {"start": time, "end": time}

    For PoC we'll just:
      - Assume lecture applies to ['ap_exam_1', 'ap_exam_2'] when in lecture window.
      - Night window sets night maintenance active.
      - Peak window toggles peak-hours block state.

    You can wire real schedule inputs from JSON/GUI later.
    """
    proposals: List[Dict[str, Any]] = []

    # LECTURE_HALL_MODE example
    if lecture_windows:
        for _, win in lecture_windows.items():
            start_t = win["start"]
            end_t = win["end"]
            if start_t <= now.time() <= end_t:
                proposals.extend(handle_lecture_hall_event("enter", ["ap_exam_1", "ap_exam_2"]))
            else:
                proposals.extend(handle_lecture_hall_event("exit", ["ap_exam_1", "ap_exam_2"]))

    # NIGHT_MAINTENANCE_WINDOW example
    if night_window:
        s = night_window["start"]
        e = night_window["end"]
        active = (s <= now.time() <= e)
        proposals.extend(handle_night_maintenance_window(active))

    # DAILY_PEAK_HOURS_BLOCK example
    if peak_window:
        s = peak_window["start"]
        e = peak_window["end"]
        active = (s <= now.time() <= e)
        proposals.extend(handle_daily_peak_hours_block(active))

    return proposals

# ================== Operational Events (OP-1 .. OP-4) ==================
from typing import List, Dict, Any

OP_STATE: Dict[str, Any] = {
    "frozen_aps": set(),          # OP-1 MANUAL_OVERRIDE_FREEZE
    "maintenance_mode": False,    # OP-2 MAINTENANCE_MODE
    "emergency_aps": set(),       # OP-3 EMERGENCY_CROWD_EVENT
    "testbed_isolated_aps": set() # OP-4 TESTBED_ISOLATION_EVENT
}


def handle_operational_event(event_code: str,
                             affected_aps: List[str],
                             meta: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    """
    Operational event dispatcher.

    event_code:
      - "OP-1" MANUAL_OVERRIDE_FREEZE
      - "OP-2" MAINTENANCE_MODE
      - "OP-3" EMERGENCY_CROWD_EVENT
      - "OP-4" TESTBED_ISOLATION_EVENT

    affected_aps: APs this operational change applies to (may be site-wide).
    meta: optional operator flags (e.g. enable / disable, power knobs).
    """
    if meta is None:
        meta = {}

    proposals: List[Dict[str, Any]] = []
    st = OP_STATE

    # ------------ OP-1 MANUAL_OVERRIDE_FREEZE ------------
    # Operator flags APs as "don't touch".
    # For PoC:
    #   - Add/remove APs from OP_STATE["frozen_aps"].
    #   - Your planner/apply_proposals should check this and ignore changes to frozen APs.
    if event_code == "OP-1":
        action = meta.get("action", "enable")  # "enable" or "disable"
        if action == "enable":
            for ap_id in affected_aps:
                st["frozen_aps"].add(ap_id)
        else:
            for ap_id in affected_aps:
                st["frozen_aps"].discard(ap_id)
        return proposals

    # ------------ OP-2 MAINTENANCE_MODE ------------
    # Site-wide test / maintenance mode.
    # Actions:
    #   - Allow more aggressive changes, relax rollback penalties, etc.
    # For PoC:
    #   - Set OP_STATE["maintenance_mode"] and optionally put fast_loop_mode="aggressive"
    if event_code == "OP-2":
        enable = meta.get("enable", True)
        st["maintenance_mode"] = enable

        for ap_id in affected_aps:
            if ap_id not in AP_BASELINE_CONFIG:
                continue
            cfg = AP_BASELINE_CONFIG[ap_id]
            new_mode = "aggressive" if enable else "normal"
            if cfg.get("fast_loop_mode") != new_mode:
                proposals.append({
                    "ap_id": ap_id,
                    "type": "fast_loop_mode",
                    "value": new_mode,
                    "reason": f"OP-2_MAINTENANCE_MODE_{'ENTER' if enable else 'EXIT'}",
                })
                cfg["fast_loop_mode"] = new_mode

        return proposals

    # ------------ OP-3 EMERGENCY_CROWD_EVENT ------------
    # Temporary spike such as festival rush, sports event.
    # Actions:
    #   - Aggressive band steering / load balancing (PoC: power shaping)
    #   - Possibly power reduction to limit contention.
    if event_code == "OP-3":
        enable = meta.get("enable", True)
        power_delta = meta.get("power_delta", -3)
        min_power_dbm = meta.get("min_power_dbm", 5.0)

        if enable:
            for ap_id in affected_aps:
                st["emergency_aps"].add(ap_id)
                if ap_id not in AP_BASELINE_CONFIG:
                    continue
                cfg = AP_BASELINE_CONFIG[ap_id]
                tel = TELEMETRY.get(ap_id, {})

                # Slight BW tighten for stability
                bw = cfg.get("bandwidth", 40)
                new_bw = 20 if bw > 20 else bw
                if new_bw != bw:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": "bandwidth",
                        "value": new_bw,
                        "reason": "OP-3_EMERGENCY_EVENT_SHRINK_BW",
                    })
                    cfg["bandwidth"] = new_bw
                    tel["bandwidth"] = new_bw

                # Power reduction to reduce contention radius
                old_pwr = float(cfg.get("txpower", 15.0))
                new_pwr = max(old_pwr + power_delta, min_power_dbm)
                if new_pwr != old_pwr:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": "txpower",
                        "value": new_pwr,
                        "reason": "OP-3_EMERGENCY_EVENT_POWER_REDUCE",
                    })
                    cfg["txpower"] = new_pwr
                    tel["txpower"] = new_pwr

        else:
            # Disable emergency mode for these APs; we don't automatically restore here
            for ap_id in affected_aps:
                st["emergency_aps"].discard(ap_id)
            # In a real system you'd pair this with a scheduled or manual reoptimization.
        return proposals

    # ------------ OP-4 TESTBED_ISOLATION_EVENT ------------
    # Operator/system isolates a set of APs for experimentation.
    # Actions:
    #   - Move them to 'safe' channels
    #   - Potentially clamp power / bandwidth
    #   - Mark them as 'isolated' so they don't get normal RRM changes
    if event_code == "OP-4":
        enable = meta.get("enable", True)

        if enable:
            for ap_id in affected_aps:
                st["testbed_isolated_aps"].add(ap_id)
                if ap_id not in AP_BASELINE_CONFIG:
                    continue
                cfg = AP_BASELINE_CONFIG[ap_id]
                tel = TELEMETRY.get(ap_id, {})

                # Put testbed APs on a fixed "lab" channel (e.g. 11) with 20 MHz
                new_ch = meta.get("isolation_channel", 11)
                if cfg.get("channel") != new_ch:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": "channel",
                        "value": new_ch,
                        "reason": "OP-4_TESTBED_ISOLATION_CHANNEL",
                    })
                    cfg["channel"] = new_ch
                    tel["channel"] = new_ch

                if cfg.get("bandwidth", 20) != 20:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": "bandwidth",
                        "value": 20,
                        "reason": "OP-4_TESTBED_ISOLATION_BW_20MHZ",
                    })
                    cfg["bandwidth"] = 20
                    tel["bandwidth"] = 20

                # Keep power moderate
                new_pwr = meta.get("isolation_power_dbm", 10.0)
                if cfg.get("txpower") != new_pwr:
                    proposals.append({
                        "ap_id": ap_id,
                        "type": "txpower",
                        "value": new_pwr,
                        "reason": "OP-4_TESTBED_ISOLATION_POWER",
                    })
                    cfg["txpower"] = new_pwr
                    tel["txpower"] = new_pwr
        else:
            for ap_id in affected_aps:
                st["testbed_isolated_aps"].discard(ap_id)
            # Config restore can be done via snapshot or slow-loop reopt later.

        return proposals

    return []

def control_step_extended(sim_date_str, sim_time_str, scenario, extra_events):
    # extra_events: list of {"kind": "RF"|"QOE"|"SCH"|"OP", "code": "RF-1", "aps": [...], "meta": {...}}

    log, cfg, tel, props = control_step(sim_date_str, sim_time_str, scenario)

    extra_props = []
    for ev in extra_events:
        kind = ev["kind"]
        code = ev["code"]
        aps  = ev.get("aps", [])
        meta = ev.get("meta", {})

        if kind == "RF":
            extra_props.extend(handle_rf_event(code, aps, meta))
        elif kind == "QOE":
            extra_props.extend(handle_qoe_event(code, aps, meta))
        elif kind == "OP":
            extra_props.extend(handle_operational_event(code, aps, meta))
        # scheduled (SCH) can be driven by time windows instead (see scheduled_events_tick)

    apply_proposals(extra_props)
    props = props + extra_props
    # ... return extended log/props if you like

from datetime import date, datetime
import gradio as gr
from typing import Dict, Any, List

today_str = date.today().strftime("%Y-%m-%d")

# ========= Helpers for pretty visualization (AP cards + timeline) =========

def build_ap_cards_html(cfg: Dict[str, Dict[str, Any]],
                        tel: Dict[str, Dict[str, Any]]) -> str:
    """
    Build a small HTML 'dashboard' of AP cards:
    - shows role, channel, bandwidth, txpower, clients, interference, exam-status
    """
    def ap_role(ap_id: str) -> str:
        if "exam" in ap_id:
            return "Exam hall"
        if "corridor" in ap_id:
            return "Near exam"
        if "canteen" in ap_id:
            return "Canteen"
        return "Other"

    exam_active = EXAM_HALL_STATE["active"]
    exam_aps = EXAM_HALL_STATE["exam_aps"]
    neighbor_aps = EXAM_HALL_STATE["neighbor_aps"]

    card_htmls = []
    for ap_id in AP_IDS:
        c = cfg[ap_id]
        t = tel[ap_id]
        role = ap_role(ap_id)

        is_exam = ap_id in exam_aps
        is_neigh = ap_id in neighbor_aps
        clients = t.get("num_clients", 0)
        interf = t.get("interference", False)

        if exam_active and is_exam:
            border = "#22c55e"  # green
            bg = "#ecfdf3"
            label = "Exam AP (ACTIVE)"
        elif exam_active and is_neigh:
            border = "#eab308"  # amber
            bg = "#fffbeb"
            label = "Neighbor (ACTIVE)"
        else:
            border = "#e5e7eb"
            bg = "#f9fafb"
            label = role

        interfer_str = "Yes" if interf else "No"
        interfer_color = "#ef4444" if interf else "#22c55e"

        card_html = f"""
        <div style="
            flex: 1 1 220px;
            border: 2px solid {border};
            border-radius: 0.75rem;
            padding: 0.75rem 0.9rem;
            margin: 0.4rem;
            background: {bg};
            font-size: 0.85rem;
            box-shadow: 0 4px 10px rgba(15,23,42,0.06);
        ">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.3rem;">
            <div style="font-weight:600;">{ap_id}</div>
            <span style="font-size:0.75rem;color:#4b5563;">{label}</span>
          </div>
          <div style="display:flex;flex-wrap:wrap;column-gap:0.75rem;row-gap:0.15rem;margin-bottom:0.35rem;">
            <div>ðŸ“¡ <b>Ch</b> {c.get('channel', '-')}</div>
            <div>ðŸ“¶ <b>BW</b> {c.get('bandwidth', '-')} MHz</div>
            <div>âš¡ <b>P</b> {c.get('txpower', '-')} dBm</div>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>ðŸ‘¥ Clients: <b>{clients}</b></div>
            <div>ðŸŒ©ï¸ Interf:
              <span style="color:{interfer_color};font-weight:600;">{interfer_str}</span>
            </div>
          </div>
        </div>
        """
        card_htmls.append(card_html)

    html = """
    <div style="display:flex;flex-wrap:wrap;justify-content:flex-start;">
    """ + "\n".join(card_htmls) + "</div>"
    return html


def build_timeline_html(sim_date_str: str, sim_time_str: str) -> str:
    """
    Render a tiny timeline against the latest exam schedule and the simulated time.
    """
    try:
        sim_date = datetime.strptime(sim_date_str, "%Y-%m-%d").date()
        sim_time = datetime.strptime(sim_time_str, "%H:%M").time()
        now_dt = datetime.combine(sim_date, sim_time)
    except Exception:
        return (
            "<div style='font-size:0.85rem;color:#ef4444;'>"
            "Could not parse simulated date/time for timeline."
            "</div>"
        )

    schedules = [s for s in load_schedules() if s.get("type") == "EXAM_HALL_QUIET_HOURS"]
    if not schedules:
        return (
            "<div style='font-size:0.85rem;color:#6b7280;'>"
            "No exam schedule defined yet. Create one in the <b>Scheduled Profiles</b> tab."
            "</div>"
        )

    sched = schedules[-1]  # latest
    exam_date = datetime.strptime(sched["date"], "%Y-%m-%d").date()
    start_t = datetime.strptime(sched["start_time"], "%H:%M:%S").time()
    end_t = datetime.strptime(sched["end_time"], "%H:%M:%S").time()
    start_dt = datetime.combine(exam_date, start_t)
    end_dt = datetime.combine(exam_date, end_t)

    if now_dt < start_dt:
        status = "Before exam window"
        color = "#0ea5e9"
    elif start_dt <= now_dt <= end_dt:
        status = "Inside exam window"
        color = "#22c55e"
    else:
        status = "After exam window"
        color = "#6b7280"

    total = (end_dt - start_dt).total_seconds() or 1
    if now_dt <= start_dt:
        pct = 0
    elif now_dt >= end_dt:
        pct = 100
    else:
        pct = int(((now_dt - start_dt).total_seconds() / total) * 100)

    html = f"""
    <div style="font-size:0.85rem;margin-top:0.4rem;">
      <div><b>Exam window:</b> {sched['date']} {start_t.strftime('%H:%M')}â€“{end_t.strftime('%H:%M')}</div>
      <div><b>Simulated time:</b> {now_dt.strftime('%Y-%m-%d %H:%M')}</div>
      <div style="margin:0.3rem 0 0.15rem 0;"><b>Status:</b> <span style="color:{color};">{status}</span></div>
      <div style="position:relative;height:8px;border-radius:999px;background:#e5e7eb;overflow:hidden;margin-top:0.25rem;">
        <div style="width:{pct}%;height:100%;background:{color};"></div>
      </div>
      <div style="text-align:right;font-size:0.75rem;color:#6b7280;margin-top:0.1rem;">
        {pct}% of exam window elapsed
      </div>
    </div>
    """
    return html


def control_step_ui(sim_date_str: str, sim_time_str: str, scenario: str):
    """
    Wraps core control_step to also build AP cards & timeline.
    """
    log, cfg, tel, props = control_step(sim_date_str, sim_time_str, scenario)
    cards_html = ""
    timeline_html = ""
    if cfg and tel:
        cards_html = build_ap_cards_html(cfg, tel)
        timeline_html = build_timeline_html(sim_date_str, sim_time_str)
    return log, cfg, tel, props, cards_html, timeline_html


# ========= Event trigger wrappers for the dashboard =========

# --- RF event labels -> codes ---
RF_EVENT_CHOICES = {
    "RF-1 â€” NON_WIFI_BURST": "RF-1",
    "RF-2 â€” NON_WIFI_PERSISTENT": "RF-2",
    "RF-3 â€” DFS_RADAR_HIT": "RF-3",
    "RF-4 â€” DFS_RADAR_CLUSTER": "RF-4",
    "RF-5 â€” OBSS_INTERFERENCE_SPIKE": "RF-5",
}

QOE_EVENT_CHOICES = {
    "QOE-1 â€” QOE_COLLAPSE_LOCAL": "QOE-1",
    "QOE-2 â€” QOE_DEGRADATION_PERSISTENT": "QOE-2",
    "QOE-3 â€” EDGE_CLIENT_RTT_SPIKE": "QOE-3",
    "QOE-4 â€” HIGH_LOAD_HOTSPOT": "QOE-4",
}

OP_EVENT_CHOICES = {
    "OP-1 â€” MANUAL_OVERRIDE_FREEZE": "OP-1",
    "OP-2 â€” MAINTENANCE_MODE": "OP-2",
    "OP-3 â€” EMERGENCY_CROWD_EVENT": "OP-3",
    "OP-4 â€” TESTBED_ISOLATION_EVENT": "OP-4",
}


def trigger_rf_event_ui(label: str,
                        ap_text: str,
                        interfered_channel: int,
                        dfs_channel: int,
                        cluster_channel: int,
                        delta_obss_pd: int,
                        power_delta: int):
    code = RF_EVENT_CHOICES[label]
    aps = parse_ap_list(ap_text)
    meta: Dict[str, Any] = {}

    if code in ("RF-1", "RF-2"):
        meta["interfered_channel"] = interfered_channel
    if code == "RF-3":
        meta["dfs_channel"] = dfs_channel
    if code == "RF-4":
        meta["cluster_channel"] = cluster_channel
    if code == "RF-5":
        meta["delta_obss_pd"] = delta_obss_pd
        meta["power_delta"] = power_delta

    proposals = handle_rf_event(code, aps, meta)
    apply_proposals(proposals)

    # Build short log
    lines = [f"Triggered {code} on {aps} with meta={meta}"]
    if not proposals:
        lines.append("No proposals generated (may already be mitigated).")
    else:
        lines.append("Proposals:")
        for p in proposals:
            lines.append(f"  - {p['ap_id']}: {p['type']} -> {p['value']} ({p['reason']})")

    log = "\n".join(lines)
    cards_html = build_ap_cards_html(AP_BASELINE_CONFIG, TELEMETRY)
    return log, proposals, cards_html


def trigger_qoe_event_ui(label: str,
                         ap_text: str,
                         delta_obss_pd: int,
                         power_delta: int):
    code = QOE_EVENT_CHOICES[label]
    aps = parse_ap_list(ap_text)
    meta: Dict[str, Any] = {
        "delta_obss_pd": delta_obss_pd,
        "power_delta": power_delta,
    }
    proposals = handle_qoe_event(code, aps, meta)
    apply_proposals(proposals)

    lines = [f"Triggered {code} on {aps} with meta={meta}"]
    if not proposals:
        lines.append("No proposals generated (may already be mitigated).")
    else:
        lines.append("Proposals:")
        for p in proposals:
            lines.append(f"  - {p['ap_id']}: {p['type']} -> {p['value']} ({p['reason']})")

    log = "\n".join(lines)
    cards_html = build_ap_cards_html(AP_BASELINE_CONFIG, TELEMETRY)
    return log, proposals, cards_html


def trigger_op_event_ui(label: str,
                        ap_text: str,
                        action: str,
                        enable_flag: bool,
                        power_delta: int,
                        isolation_channel: int,
                        isolation_power_dbm: float):
    code = OP_EVENT_CHOICES[label]
    aps = parse_ap_list(ap_text) or AP_IDS  # if empty, treat as "all APs"
    meta: Dict[str, Any] = {}

    if code == "OP-1":  # freeze
        meta["action"] = action  # enable/disable
    elif code == "OP-2":  # maintenance
        meta["enable"] = enable_flag
    elif code == "OP-3":  # emergency crowd
        meta["enable"] = enable_flag
        meta["power_delta"] = power_delta
    elif code == "OP-4":  # testbed isolation
        meta["enable"] = enable_flag
        meta["isolation_channel"] = isolation_channel
        meta["isolation_power_dbm"] = isolation_power_dbm

    proposals = handle_operational_event(code, aps, meta)
    apply_proposals(proposals)

    lines = [f"Triggered {code} on {aps} with meta={meta}"]
    if not proposals:
        lines.append("No proposals generated (state-only op or already applied).")
    else:
        lines.append("Proposals:")
        for p in proposals:
            lines.append(f"  - {p['ap_id']}: {p['type']} -> {p['value']} ({p['reason']})")

    log = "\n".join(lines)
    cards_html = build_ap_cards_html(AP_BASELINE_CONFIG, TELEMETRY)
    return log, proposals, cards_html


# ========= Super Dashboard =========

with gr.Blocks(
    title="RRM Event-Loop Controller Dashboard",
    theme=gr.themes.Soft(primary_hue="blue", secondary_hue="slate"),
) as dashboard:
    # ----- HEADER -----
    gr.HTML(
        """
        <div style="text-align:center; padding: 0.5rem 0 1.2rem 0;">
          <h1 style="margin-bottom:0.3rem;">ðŸ“¡ RRM Event-Loop Controller Dashboard</h1>
          <p style="font-size:0.95rem; color:#4b5563; max-width:780px; margin: 0 auto;">
            End-to-end proof-of-concept for a <b>policy-driven RRM controller</b>:
            RF / Spectrum events, QoE incidents, Scheduled profiles, and Operational overrides
            all converging into a single event-loop and fast-loop.
          </p>
        </div>
        """
    )

    with gr.Tabs():
        # ================= TAB 1: LIVE CONTROLLER =================
        with gr.Tab("1ï¸âƒ£ Live Controller"):
            gr.Markdown(
                """
                ### ðŸ§  Controller Step (Event Loop + Fast Loop)

                1. Pick a simulated **time** and **scenario**
                2. Click **Run control step**
                3. See:
                   - Controller log
                   - AP cards (post-step)
                   - Exam timeline
                   - Raw configs + telemetry + proposals
                """
            )

            with gr.Row():
                sim_date = gr.Textbox(
                    label="Simulated date (YYYY-MM-DD)",
                    value=today_str,
                    scale=1,
                )
                sim_time = gr.Textbox(
                    label="Simulated time (HH:MM)",
                    value="09:30",
                    scale=1,
                )
                scenario = gr.Radio(
                    label="Scenario",
                    choices=["normal", "exam_rush", "exam_interference"],
                    value="exam_rush",
                    interactive=True,
                )

            with gr.Row():
                run_btn = gr.Button("â–¶ï¸ Run one control step", variant="primary", scale=2)
                reset_btn = gr.Button("â™»ï¸ Reset simulation state", variant="secondary")

            with gr.Row():
                with gr.Column(scale=2):
                    log_out = gr.Textbox(
                        label="Controller log",
                        lines=12,
                        show_label=True,
                    )
                    timeline_html = gr.HTML()

                with gr.Column(scale=3):
                    ap_cards_html = gr.HTML()

            cfg_out = gr.JSON(label="AP_BASELINE_CONFIG after step")
            tel_out = gr.JSON(label="TELEMETRY after step")
            props_out = gr.JSON(label="Proposals applied (event loop + fast loop)")

            run_btn.click(
                fn=control_step_ui,
                inputs=[sim_date, sim_time, scenario],
                outputs=[log_out, cfg_out, tel_out, props_out, ap_cards_html, timeline_html],
            )

            def reset_and_report():
                reset_simulation_state()
                return "âœ… Simulation state reset to initial AP configs and telemetry."

            reset_status = gr.Markdown()
            reset_btn.click(fn=reset_and_report, inputs=None, outputs=reset_status)

        # ================= TAB 2: SCHEDULED PROFILES =================
        with gr.Tab("2ï¸âƒ£ Scheduled Profiles"):
            gr.Markdown(
                """
                ### â± Scheduled SLO Profiles

                - **SCH-1 EXAM_HALL_QUIET_HOURS**
                  Strict, low-jitter config during exams (channels locked, 20 MHz, power shaping).

                - **SCH-2 LECTURE_HALL_MODE**
                  High-density but less strict: moderate bandwidth, mild power reduction.

                - **SCH-3 NIGHT_MAINTENANCE_WINDOW**
                  Allow more aggressive tuning at night.

                - **SCH-4 DAILY_PEAK_HOURS_BLOCK**
                  Block risky changes during peak hours (state flag for your planner).
                """
            )

            # ---- Exam schedule editor (SCH-1) ----
            with gr.Accordion("ðŸŽ“ SCH-1 â€” Exam Hall Quiet Hours (schedule-based)", open=True):
                exam_date = gr.Textbox(
                    label="Exam date (YYYY-MM-DD)",
                    value=today_str,
                    placeholder="2025-12-04",
                )
                with gr.Row():
                    start_time = gr.Textbox(
                        label="Start time (HH:MM)",
                        value="09:00",
                        placeholder="09:00",
                    )
                    end_time = gr.Textbox(
                        label="End time (HH:MM)",
                        value="12:00",
                        placeholder="12:00",
                    )
                with gr.Row():
                    exam_aps_text = gr.Textbox(
                        label="Exam hall AP IDs",
                        value="ap_exam_1, ap_exam_2",
                        placeholder="ap_exam_1, ap_exam_2",
                    )
                    neighbor_aps_text = gr.Textbox(
                        label="Neighbor AP IDs",
                        value="ap_corridor_1, ap_corridor_2",
                        placeholder="ap_corridor_1, ap_corridor_2",
                    )

                gr.Markdown("**Policy knobs for exam SLO**")
                with gr.Row():
                    power_boost_db = gr.Slider(
                        label="Exam AP power boost (dB)",
                        minimum=0,
                        maximum=6,
                        step=1,
                        value=3,
                    )
                    power_reduce_db = gr.Slider(
                        label="Neighbor AP power reduction (dB)",
                        minimum=0,
                        maximum=6,
                        step=1,
                        value=3,
                    )
                with gr.Row():
                    force_20_mhz = gr.Checkbox(
                        label="Force 20 MHz during exam", value=True
                    )
                    conservative_mode = gr.Checkbox(
                        label="Conservative fast-loop mode", value=True
                    )

                schedule_btn = gr.Button("âœ… Add Exam Hall Schedule", variant="primary")
                clear_sched_btn = gr.Button("ðŸ§¹ Clear all exam schedules", variant="secondary")

                status_out = gr.Markdown()
                created_json = gr.JSON(label="Last created exam schedule")

                schedule_btn.click(
                    fn=schedule_exam_entry,
                    inputs=[
                        exam_date,
                        start_time,
                        end_time,
                        exam_aps_text,
                        neighbor_aps_text,
                        power_boost_db,
                        power_reduce_db,
                        force_20_mhz,
                        conservative_mode,
                    ],
                    outputs=[status_out, created_json],
                )

                def clear_schedules():
                    save_schedules([])
                    return "ðŸ§¹ Cleared all exam schedules.", {"schedules": []}

                gr.Markdown("**Existing exam schedules (exam_schedules.json)**")
                view_btn = gr.Button("ðŸ”„ Refresh exam schedules")
                schedules_json = gr.JSON(label="All exam schedule entries")

                view_btn.click(fn=view_schedules, inputs=None, outputs=schedules_json)
                clear_sched_btn.click(
                    fn=clear_schedules, inputs=None, outputs=[status_out, schedules_json]
                )

            # ---- Lecture / Night / Peak toggles ----
            with gr.Accordion("ðŸ« SCH-2 / SCH-3 / SCH-4 â€” Mode Toggles (for demo)", open=False):
                gr.Markdown(
                    "These toggles apply scheduled modes immediately for the PoC. "
                    "In a real deployment they'd be driven by a calendar service."
                )
                # LECTURE_HALL_MODE
                lecture_toggle = gr.Checkbox(
                    label="SCH-2 LECTURE_HALL_MODE (ap_exam_1, ap_exam_2)",
                    value=False,
                )
                # NIGHT_MAINTENANCE
                night_toggle = gr.Checkbox(
                    label="SCH-3 NIGHT_MAINTENANCE_WINDOW (all APs)",
                    value=False,
                )
                # DAILY_PEAK_HOURS_BLOCK
                peak_toggle = gr.Checkbox(
                    label="SCH-4 DAILY_PEAK_HOURS_BLOCK (planner state flag)",
                    value=False,
                )

                scheduled_status = gr.Markdown()
                scheduled_cards = gr.HTML()

                def apply_scheduled_toggles(lecture_active, night_active, peak_active):
                    now = datetime.now()
                    props: List[Dict[str, Any]] = []
                    # Lecture applies to exam APs
                    phase = "enter" if lecture_active else "exit"
                    props.extend(handle_lecture_hall_event(phase, ["ap_exam_1", "ap_exam_2"]))
                    # Night maintenance
                    props.extend(handle_night_maintenance_window(night_active))
                    # Peak hours block
                    props.extend(handle_daily_peak_hours_block(peak_active))

                    apply_proposals(props)
                    lines = ["Scheduled profile toggles applied:"]
                    if not props:
                        lines.append("- No config changes (possibly already in that state).")
                    else:
                        for p in props:
                            lines.append(f"- {p['ap_id']}: {p['type']} -> {p['value']} ({p['reason']})")
                    cards_html = build_ap_cards_html(AP_BASELINE_CONFIG, TELEMETRY)
                    return "\n".join(lines), cards_html

                apply_sched_btn = gr.Button("âš™ï¸ Apply scheduled mode toggles")
                apply_sched_btn.click(
                    fn=apply_scheduled_toggles,
                    inputs=[lecture_toggle, night_toggle, peak_toggle],
                    outputs=[scheduled_status, scheduled_cards],
                )

        # ================= TAB 3: RF & QoE Events =================
        with gr.Tab("3ï¸âƒ£ RF & QoE Events"):
            gr.Markdown(
                """
                ### ðŸŒ RF / Spectrum & ðŸ“ˆ QoE Triggers

                Use this tab to inject specific event types directly into the controller,
                see the proposals, and watch the AP cards update.
                """
            )

            with gr.Row():
                with gr.Column():
                    with gr.Accordion("ðŸŒˆ RF / Spectrum Events (RF-1 .. RF-5)", open=True):
                        rf_event_label = gr.Dropdown(
                            label="RF Event",
                            choices=list(RF_EVENT_CHOICES.keys()),
                            value="RF-1 â€” NON_WIFI_BURST",
                        )
                        rf_aps_text = gr.Textbox(
                            label="Affected AP IDs (comma-separated)",
                            value="ap_exam_1",
                            placeholder="ap_exam_1, ap_exam_2",
                        )
                        gr.Markdown("**Optional RF parameters**")
                        rf_interfered_ch = gr.Number(
                            label="interfered_channel / cluster_channel",
                            value=1,
                            precision=0,
                        )
                        rf_dfs_ch = gr.Number(
                            label="dfs_channel",
                            value=36,
                            precision=0,
                        )
                        rf_delta_pd = gr.Number(
                            label="delta_obss_pd (for RF-5)",
                            value=4,
                            precision=0,
                        )
                        rf_power_delta = gr.Number(
                            label="power_delta dB (for RF-5)",
                            value=-2,
                            precision=0,
                        )

                        rf_btn = gr.Button("âš¡ Trigger RF event", variant="primary")
                        rf_log = gr.Textbox(
                            label="RF event log",
                            lines=10,
                        )
                        rf_props = gr.JSON(label="RF proposals")

                    # QoE
                    with gr.Accordion("ðŸ“ˆ QoE / KPI Events (QOE-1 .. QOE-4)", open=False):
                        qoe_event_label = gr.Dropdown(
                            label="QoE Event",
                            choices=list(QOE_EVENT_CHOICES.keys()),
                            value="QOE-1 â€” QOE_COLLAPSE_LOCAL",
                        )
                        qoe_aps_text = gr.Textbox(
                            label="Affected AP IDs (comma-separated)",
                            value="ap_exam_1",
                            placeholder="ap_exam_1, ap_canteen",
                        )
                        qoe_delta_pd = gr.Number(
                            label="delta_obss_pd (dB)",
                            value=2,
                            precision=0,
                        )
                        qoe_power_delta = gr.Number(
                            label="power_delta (dB; negative=reduce, positive=boost)",
                            value=-1,
                            precision=0,
                        )

                        qoe_btn = gr.Button("ðŸ“‰ Trigger QoE event", variant="primary")
                        qoe_log = gr.Textbox(
                            label="QoE event log",
                            lines=10,
                        )
                        qoe_props = gr.JSON(label="QoE proposals")

                with gr.Column():
                    gr.Markdown("### ðŸ“¡ AP snapshot after RF / QoE actions")
                    ap_cards_rf_qoe = gr.HTML()

            rf_btn.click(
                fn=trigger_rf_event_ui,
                inputs=[
                    rf_event_label,
                    rf_aps_text,
                    rf_interfered_ch,
                    rf_dfs_ch,
                    rf_interfered_ch,  # cluster_channel share same field
                    rf_delta_pd,
                    rf_power_delta,
                ],
                outputs=[rf_log, rf_props, ap_cards_rf_qoe],
            )

            qoe_btn.click(
                fn=trigger_qoe_event_ui,
                inputs=[
                    qoe_event_label,
                    qoe_aps_text,
                    qoe_delta_pd,
                    qoe_power_delta,
                ],
                outputs=[qoe_log, qoe_props, ap_cards_rf_qoe],
            )

        # ================= TAB 4: Operational Events =================
        with gr.Tab("4ï¸âƒ£ Operational Overrides"):
            gr.Markdown(
                """
                ### ðŸ›  Operational & Manual Events

                These are operator-driven or system-driven overrides that sit above
                regular RRM policies.
                """
            )

            with gr.Row():
                with gr.Column():
                    op_event_label = gr.Dropdown(
                        label="Operational Event",
                        choices=list(OP_EVENT_CHOICES.keys()),
                        value="OP-1 â€” MANUAL_OVERRIDE_FREEZE",
                    )
                    op_aps_text = gr.Textbox(
                        label="Affected AP IDs (empty = all)",
                        value="ap_exam_1",
                        placeholder="ap_exam_1, ap_corridor_1",
                    )

                    op_action = gr.Radio(
                        label="Action (for OP-1 freeze)",
                        choices=["enable", "disable"],
                        value="enable",
                    )
                    op_enable_flag = gr.Checkbox(
                        label="Enable flag (OP-2/OP-3/OP-4)",
                        value=True,
                    )
                    op_power_delta = gr.Number(
                        label="power_delta (for OP-3 emergency, dB)",
                        value=-3,
                        precision=0,
                    )
                    op_iso_channel = gr.Number(
                        label="isolation_channel (for OP-4 testbed)",
                        value=11,
                        precision=0,
                    )
                    op_iso_power = gr.Number(
                        label="isolation_power_dbm (for OP-4 testbed)",
                        value=10.0,
                    )

                    op_btn = gr.Button("ðŸ›  Apply operational event", variant="primary")
                    op_log = gr.Textbox(
                        label="Operational event log",
                        lines=10,
                    )
                    op_props = gr.JSON(label="Operational proposals")

                with gr.Column():
                    gr.Markdown("### ðŸ” AP snapshot after operational changes")
                    ap_cards_op = gr.HTML()

            op_btn.click(
                fn=trigger_op_event_ui,
                inputs=[
                    op_event_label,
                    op_aps_text,
                    op_action,
                    op_enable_flag,
                    op_power_delta,
                    op_iso_channel,
                    op_iso_power,
                ],
                outputs=[op_log, op_props, ap_cards_op],
            )

dashboard.launch()