options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: Interference
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: Injection_Frequency
  id: variable
  parameters:
    comment: ''
    value: int(2.44e9)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1360, 64.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '20000000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [184, 12]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"Realistic Microwave Oven Interference - Dynamic FFT Shaping v4\"\"\
      \"\n\n    def __init__(self,\n                 samp_rate=1e6,\n            \
      \     burst_rate=100,\n                 duty_cycle=0.40,\n                 noise_amp=1.0,\n\
      \                 wobble_freq=3.0,\n                 wobble_depth=0.12,\n  \
      \               hump_width=0.55,     # <<< STRONG microwave-like width\n   \
      \              hump_gain=15.0):     # <<< STRONG microwave-like intensity\n\n\
      \        gr.sync_block.__init__(\n            self,\n            name='Microwave\
      \ Oven (FFT-Shaped Dynamic v4)',\n            in_sig=None,\n            out_sig=[np.complex64]\n\
      \        )\n\n        # Store parameters\n        self.samp_rate = samp_rate\n\
      \        self.burst_rate = burst_rate\n        self.duty_cycle = duty_cycle\n\
      \        self.noise_amp = noise_amp\n        self.wobble_freq = wobble_freq\n\
      \        self.wobble_depth = wobble_depth\n        self.hump_width = hump_width\n\
      \        self.hump_gain = hump_gain\n\n        # Burst timing\n        self.samples_per_period\
      \ = int(samp_rate / burst_rate)\n        self.samples_on = int(self.samples_per_period\
      \ * duty_cycle)\n        self.counter = 0\n        self.time_idx = 0\n     \
      \   self.phase = 0\n\n\n    def work(self, input_items, output_items):\n   \
      \     out = output_items[0]\n        n = len(out)\n\n        # Time vector\n\
      \        t = (np.arange(n) + self.time_idx) / self.samp_rate\n\n        # 1\
      \ \u2014 Base noise (complex)\n        noise = (np.random.normal(0, self.noise_amp,\
      \ n) +\n                 1j*np.random.normal(0, self.noise_amp, n))\n\n    \
      \    # 2 \u2014 FFT-shaping (dynamic, based on buffer size)\n        F = np.fft.fftshift(np.fft.fft(noise))\n\
      \n        # Frequency axis for shaping curve\n        freqs = np.linspace(-1,\
      \ 1, n)\n\n        # Microwave hump (Gaussian bell shape across spectrum)\n\
      \        shape = 1 + self.hump_gain * np.exp(-(freqs / self.hump_width)**2)\n\
      \n        # 3 \u2014 Add MANY cavity-mode spikes (microwave textures)\n    \
      \    spikes = np.zeros(n)\n        for _ in range(120):     # <<< Increased\
      \ for realism\n            pos = np.random.randint(0, n)\n            spikes[pos]\
      \ = np.random.uniform(0.4, 1.0)\n\n        # Smooth the spikes (spread them\
      \ a little)\n        spikes = np.convolve(spikes, np.hanning(61), mode=\"same\"\
      )\n\n        # Combine with hump\n        shape += spikes\n\n        # Apply\
      \ shaping window\n        F *= shape\n\n        # Back to time-domain\n    \
      \    shaped = np.fft.ifft(np.fft.ifftshift(F))\n\n        # 4 \u2014 Magnetron\
      \ wobble (cause center drift)\n        wobble = self.wobble_depth * np.sin(2*np.pi*self.wobble_freq\
      \ * t)\n        phase_drift = np.cumsum(2*np.pi * wobble)\n        shaped *=\
      \ np.exp(1j * phase_drift)\n\n        # 5 \u2014 Burst gating\n        for i\
      \ in range(n):\n            if self.counter < self.samples_on:\n           \
      \     out[i] = np.complex64(shaped[i])\n            else:\n                out[i]\
      \ = 0\n\n            self.counter += 1\n            if self.counter >= self.samples_per_period:\n\
      \                self.counter = 0\n\n        # Update time\n        self.time_idx\
      \ += n\n        return n\n\n"
    affinity: ''
    alias: ''
    burst_rate: '100'
    comment: ''
    duty_cycle: '0.3'
    hump_gain: '3.0'
    hump_width: '0.35'
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_amp: '0.8'
    samp_rate: samp_rate
    wobble_depth: '0.15'
    wobble_freq: '2.0'
  states:
    _io_cache: ('Microwave Oven (FFT-Shaped Dynamic v4)', 'blk', [('samp_rate', '1000000.0'),
      ('burst_rate', '100'), ('duty_cycle', '0.4'), ('noise_amp', '1.0'), ('wobble_freq',
      '3.0'), ('wobble_depth', '0.12'), ('hump_width', '0.55'), ('hump_gain', '15.0')],
      [], [('0', 'complex', 1)], 'Realistic Microwave Oven Interference - Dynamic
      FFT Shaping v4', ['burst_rate', 'duty_cycle', 'hump_gain', 'hump_width', 'noise_amp',
      'samp_rate', 'wobble_depth', 'wobble_freq'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [320, 20.0]
    rotation: 0
    state: disabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"Continuous ZigBee-like interference for 4 MHz sample rate\"\"\"\n\
      \n    def __init__(self,\n                 samp_rate=4e6,        # Works with\
      \ 4 MHz\n                 center_freq=2.44e9,   # ZigBee Ch.18\n           \
      \      chip_rate=2e6,        # ZigBee chips\n                 gain=0.8):   \
      \         # Interference power\n\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='ZigBee Interference (Continuous)',\n         \
      \   in_sig=None,\n            out_sig=[np.complex64]\n        )\n\n        self.samp_rate\
      \ = samp_rate\n        self.center_freq = center_freq\n        self.chip_rate\
      \ = chip_rate\n        self.gain = gain\n\n        # ZigBee 32-chip sequence\
      \ (one example)\n        self.sequence = np.array(\n            [1,1,1,-1,1,1,-1,1,1,-1,-1,-1,-1,\
      \ 1,-1, 1, 1,1,-1,-1,\n             1,-1,-1, 1,-1, 1,-1,-1,-1, 1,1,1]\n    \
      \    )\n\n        # samples per chip ( = 2 at 4MHz SR)\n        self.sps = max(1,\
      \ int(self.samp_rate / self.chip_rate))\n\n        # pre-generate continuous\
      \ baseband chipstream\n        self.offset = 0\n\n\n    def work(self, input_items,\
      \ output_items):\n        out = output_items[0]\n        n = len(out)\n\n  \
      \      # Repeat chips enough times to fill n samples\n        repeated = np.repeat(self.sequence,\
      \ self.sps)\n\n        # Continuous wraparound indexing\n        data = np.zeros(n,\
      \ dtype=np.complex64)\n        for i in range(n):\n            idx = (self.offset\
      \ + i) % len(repeated)\n            data[i] = repeated[idx]\n\n        self.offset\
      \ = (self.offset + n) % len(repeated)\n\n        # random Q-phase (simple OQPSK-like)\n\
      \        phase = np.exp(1j * np.pi * (np.random.rand() * 2 - 1))\n\n       \
      \ out[:] = (data * phase * self.gain).astype(np.complex64)\n        return n\n\
      \t\n"
    affinity: ''
    alias: ''
    center_freq: int(2.44e9)
    chip_rate: '2000000.0'
    comment: ''
    gain: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: int(samp_rate)
  states:
    _io_cache: ('ZigBee Interference (Continuous)', 'blk', [('samp_rate', '4000000.0'),
      ('center_freq', '2440000000.0'), ('chip_rate', '2000000.0'), ('gain', '0.8')],
      [], [('0', 'complex', 1)], 'Continuous ZigBee-like interference for 4 MHz sample
      rate', ['center_freq', 'chip_rate', 'gain', 'samp_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 200.0]
    rotation: 0
    state: disabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"BLE Burst FHSS Interference Generator (with full default values)\"\
      \"\"\n\n    def __init__(self,\n                 samp_rate=4e6,       # Default:\
      \ 4 MHz (works perfectly on PlutoSDR)\n                 ble_bw=1e6,        \
      \  # Default BLE channel width\n                 hop_rate=1600,       # Default\
      \ BLE hop rate (1600 hops/sec)\n                 burst_ms=4,          # Default\
      \ burst length = 4 ms\n                 gain=0.8):           # Default interference\
      \ strength\n\n        gr.sync_block.__init__(\n            self,\n         \
      \   name='BLE FHSS Burst Interference',\n            in_sig=None,\n        \
      \    out_sig=[np.complex64]\n        )\n\n        # Save defaults\n        self.samp_rate\
      \ = samp_rate\n        self.ble_bw = ble_bw\n        self.hop_rate = hop_rate\n\
      \        self.burst_ms = burst_ms\n        self.gain = gain\n\n        # Compute\
      \ burst length in samples\n        self.burst_len = int((burst_ms / 1000.0)\
      \ * samp_rate)\n\n        # Normalize BLE hopping positions (40 BLE channels\
      \ across spectrum)\n        self.channels = np.linspace(-0.5, 0.5, 40)\n\n \
      \       self.t = 0                 # time index\n        self.current_channel\
      \ = 0   # current BLE hop index\n\n\n    def _make_ble_mask(self, n, channel_pos):\n\
      \        \"\"\"Create BLE GFSK-like 1 MHz spectral mask centered at channel_pos.\"\
      \"\"\n        freqs = np.linspace(-0.5, 0.5, n)\n        bw_norm = self.ble_bw\
      \ / self.samp_rate\n        rolloff = 0.25\n\n        mask = np.zeros(n)\n \
      \       for i, f in enumerate(freqs):\n            fshift = abs(f - channel_pos)\n\
      \n            if fshift <= (bw_norm/2)*(1-rolloff):\n                mask[i]\
      \ = 1.0\n            elif fshift <= (bw_norm/2)*(1+rolloff):\n             \
      \   x = (fshift - (bw_norm/2)*(1-rolloff)) / (bw_norm*rolloff)\n           \
      \     mask[i] = 0.5 * (1 + np.cos(np.pi * x))\n\n        return mask\n\n\n \
      \   def work(self, input_items, output_items):\n        out = output_items[0]\n\
      \        n = len(out)\n\n        #\n        # 1) Burst ON/OFF pattern\n    \
      \    #\n        if (self.t // self.burst_len) % 2 == 0:\n            active\
      \ = True\n        else:\n            active = False\n\n        #\n        #\
      \ 2) BLE hopping logic\n        #\n        hop_interval_samples = int(self.samp_rate\
      \ / self.hop_rate)\n        if hop_interval_samples < 1:\n            hop_interval_samples\
      \ = 1\n\n        if self.t % hop_interval_samples == 0:\n            self.current_channel\
      \ = np.random.randint(0, 40)\n\n        #\n        # 3) Generate white noise\
      \ base\n        #\n        noise = (np.random.normal(0, 1, n) +\n          \
      \       1j * np.random.normal(0, 1, n))\n\n        #\n        # 4) If burst\
      \ active \u2192 shape interference into BLE channel\n        #\n        if active:\n\
      \            F = np.fft.fftshift(np.fft.fft(noise))\n\n            channel_pos\
      \ = self.channels[self.current_channel]\n            mask = self._make_ble_mask(n,\
      \ channel_pos) * self.gain\n\n            F *= mask\n            shaped = np.fft.ifft(np.fft.ifftshift(F))\n\
      \        else:\n            shaped = np.zeros(n, dtype=np.complex64)\n\n   \
      \     out[:] = shaped.astype(np.complex64)\n        self.t += n\n        return\
      \ n\n\n"
    affinity: ''
    alias: ''
    ble_bw: '1000000.0'
    burst_ms: '4'
    comment: ''
    gain: '0.8'
    hop_rate: '1600'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: '4000000.0'
  states:
    _io_cache: ('BLE FHSS Burst Interference', 'blk', [('samp_rate', '4000000.0'),
      ('ble_bw', '1000000.0'), ('hop_rate', '1600'), ('burst_ms', '4'), ('gain', '0.8')],
      [], [('0', 'complex', 1)], 'BLE Burst FHSS Interference Generator (with full
      default values)', ['ble_bw', 'burst_ms', 'gain', 'hop_rate', 'samp_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [320, 312.0]
    rotation: 0
    state: disabled
- name: epy_block_3
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    Multi-FHSS Interference Generator (Simulation Only)\n    -\
      \ Works with QT sinks for visualization\n    - All defaults handled internally\n\
      \    \"\"\"\n\n    def __init__(self,\n                 samp_rate=4e6,     \
      \   # Default: 4 MHz\n                 num_hoppers=5,        # Default: 5 FHSS\
      \ devices\n                 hop_rate=1000,        # Default: 1000 hops/sec\n\
      \                 num_channels=40,      # Default: 40 channels\n           \
      \      tone_bw=300e3,        # Default: 300 kHz spike width\n              \
      \   gain=1.0):            # Default: amplitude\n\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Multi-FHSS Interference (Default)',\n\
      \            in_sig=None,\n            out_sig=[np.complex64]\n        )\n\n\
      \        # Store defaults\n        self.samp_rate = samp_rate\n        self.num_hoppers\
      \ = num_hoppers\n        self.hop_rate = hop_rate\n        self.num_channels\
      \ = num_channels\n        self.tone_bw = tone_bw\n        self.gain = gain\n\
      \n        # Hop interval in samples\n        self.hop_interval = max(1, int(self.samp_rate\
      \ / self.hop_rate))\n\n        # FHSS channel positions normalized (-0.5 to\
      \ +0.5)\n        self.channels = np.linspace(-0.5, 0.5, self.num_channels)\n\
      \n        # Per-hopper random states\n        self.current_channel = np.random.randint(0,\
      \ self.num_channels, self.num_hoppers)\n        self.t = 0\n\n\n    def _make_mask(self,\
      \ nfft, pos):\n        \"\"\"Gaussian spike mask at normalized channel position\
      \ 'pos'\"\"\"\n        f = np.linspace(-0.5, 0.5, nfft)\n        bw = self.tone_bw\
      \ / self.samp_rate\n        sigma = bw / 3\n        return np.exp(-0.5 * ((f\
      \ - pos) / sigma) ** 2)\n\n\n    def work(self, input_items, output_items):\n\
      \        out = output_items[0]\n        n = len(out)\n\n        result = np.zeros(n,\
      \ dtype=np.complex64)\n\n        # Generate interference from each FHSS device\n\
      \        for h in range(self.num_hoppers):\n\n            # Hop on boundary\n\
      \            if self.t % self.hop_interval == 0:\n                self.current_channel[h]\
      \ = np.random.randint(0, self.num_channels)\n\n            # Base noise\n  \
      \          noise = (np.random.normal(0, 1, n) +\n                     1j * np.random.normal(0,\
      \ 1, n))\n\n            # Frequency shaping\n            F = np.fft.fftshift(np.fft.fft(noise))\n\
      \            mask = self._make_mask(n, self.channels[self.current_channel[h]])\n\
      \            F *= mask * self.gain\n            shaped = np.fft.ifft(np.fft.ifftshift(F))\n\
      \n            result += shaped\n\n        # Normalize\n        m = np.max(np.abs(result))\n\
      \        if m > 0:\n            result /= m\n\n        out[:] = result.astype(np.complex64)\n\
      \        self.t += n\n        return n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    gain: '1.0'
    hop_rate: '800'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_channels: '40'
    num_hoppers: '5'
    samp_rate: '4000000.0'
    tone_bw: '300000'
  states:
    _io_cache: ('Multi-FHSS Interference (Default)', 'blk', [('samp_rate', '4000000.0'),
      ('num_hoppers', '5'), ('hop_rate', '1000'), ('num_channels', '40'), ('tone_bw',
      '300000.0'), ('gain', '1.0')], [], [('0', 'complex', 1)], '\n    Multi-FHSS
      Interference Generator (Simulation Only)\n    - Works with QT sinks for visualization\n    -
      All defaults handled internally\n    ', ['gain', 'hop_rate', 'num_channels',
      'num_hoppers', 'samp_rate', 'tone_bw'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 444.0]
    rotation: 0
    state: disabled
- name: epy_block_4
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    Realistic DFS Radar Signal (Type-1)\n    Simulation-only radar\
      \ pulses for visualization in QT sinks.\n    DEFAULT PARAMETERS IMPLEMENT FCC/ETSI\
      \ DFS RADAR TYPE-1.\n    \"\"\"\n\n    def __init__(self,\n                \
      \ samp_rate=20e6,          # 20 MHz required for 1 \xB5s resolution\n      \
      \           pulse_width_us=1.0,      # Pulse width (1 \xB5s)\n             \
      \    pulses_per_burst=9,      # DFS Type 1 = 9 pulses\n                 pri_us=1428.0,\
      \           # Pulse Repetition Interval (1428 \xB5s)\n                 burst_interval_ms=1000,\
      \  # One burst every 1 second\n                 radar_bw=3e6,            # ~3\
      \ MHz radar bandwidth\n                 gain=1.0):               # amplitude\n\
      \        gr.sync_block.__init__(\n            self,\n            name='DFS Radar\
      \ (Type-1)',\n            in_sig=None,\n            out_sig=[np.complex64]\n\
      \        )\n\n        # Save defaults\n        self.samp_rate = samp_rate\n\
      \        self.pulse_width = int((pulse_width_us / 1e6) * samp_rate)\n      \
      \  self.pulses_per_burst = pulses_per_burst\n        self.pri = int((pri_us\
      \ / 1e6) * samp_rate)\n        self.burst_interval = int((burst_interval_ms\
      \ / 1000.0) * samp_rate)\n        self.radar_bw = radar_bw\n        self.gain\
      \ = gain\n\n        # Internal time index\n        self.t = 0\n\n\n    def work(self,\
      \ input_items, output_items):\n        out = output_items[0]\n        n = len(out)\n\
      \n        # Output buffer\n        radar = np.zeros(n, dtype=np.complex64)\n\
      \n        # Local time vector\n        t_local = np.arange(n)\n\n        # Current\
      \ time inside repeating burst cycle\n        cycle_pos = (self.t + t_local)\
      \ % self.burst_interval\n\n        # For each pulse in the burst\n        for\
      \ p in range(self.pulses_per_burst):\n            # Pulse start time in samples\n\
      \            pulse_start = p * self.pri\n            pulse_end = pulse_start\
      \ + self.pulse_width\n\n            # Boolean mask for pulse presence\n    \
      \        pulse_mask = np.logical_and(cycle_pos >= pulse_start,\n           \
      \                             cycle_pos < pulse_end)\n\n            # Radar\
      \ pulse = complex amplitude (carrier is baseband)\n            radar[pulse_mask]\
      \ = self.gain + 0j\n\n        # BANDWIDTH SHAPING (Radar \u2248 3 MHz)\n   \
      \     if self.radar_bw > 0:\n            # Create colored noise\n          \
      \  noise = (np.random.normal(0, 0.05, n) +\n                     1j * np.random.normal(0,\
      \ 0.05, n)).astype(np.complex64)\n\n            # Shape noise with Gaussian\
      \ spectral mask\n            freqs = np.linspace(-self.samp_rate/2, self.samp_rate/2,\
      \ n)\n            mask = np.exp(-0.5 * (freqs / (self.radar_bw/2))**2)\n\n \
      \           F = np.fft.fftshift(np.fft.fft(noise))\n            F *= mask\n\
      \            shaped_noise = np.fft.ifft(np.fft.ifftshift(F))\n\n           \
      \ radar += shaped_noise.astype(np.complex64)\n\n        # Write output\n   \
      \     out[:] = radar\n        self.t += n\n        return n\n\n"
    affinity: ''
    alias: ''
    burst_interval_ms: '1000'
    comment: ''
    gain: '3.0'
    maxoutbuf: '0'
    minoutbuf: '0'
    pri_us: '1428.0'
    pulse_width_us: '1.0'
    pulses_per_burst: '9'
    radar_bw: '3000000.0'
    samp_rate: '20000000.0'
  states:
    _io_cache: ('DFS Radar (Type-1)', 'blk', [('samp_rate', '20000000.0'), ('pulse_width_us',
      '1.0'), ('pulses_per_burst', '9'), ('pri_us', '1428.0'), ('burst_interval_ms',
      '1000'), ('radar_bw', '3000000.0'), ('gain', '1.0')], [], [('0', 'complex',
      1)], '\n    Realistic DFS Radar Signal (Type-1)\n    Simulation-only radar pulses
      for visualization in QT sinks.\n    DEFAULT PARAMETERS IMPLEMENT FCC/ETSI DFS
      RADAR TYPE-1.\n    ', ['gain', 'pulses_per_burst', 'radar_bw', 'samp_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [176, 716.0]
    rotation: 0
    state: enabled
- name: epy_block_5
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    Realistic DFS Radar Type-2 (FCC / ETSI Standard)\n    - Pulse\
      \ width: 5 us\n    - PRI: 200 us\n    - Pulses per burst: 10\n    - Burst interval:\
      \ 250 ms\n    - Bandwidth ~6 MHz\n    \"\"\"\n\n    def __init__(self,\n   \
      \              samp_rate=20e6,          # 20 MHz required for 5 us pulse shaping\n\
      \                 center_freq=5260e6,      # visual center frequency\n     \
      \            pulse_width_us=5.0,      # DFS Type-2 official value: 5 us\n  \
      \               pri_us=200.0,            # PRI = 200 us\n                 pulses_per_burst=10,\
      \     # Type-2: 8\u201320; default = 10\n                 burst_interval_ms=250,\
      \   # DFS standard: 250 ms burst interval\n                 radar_bw=6e6,  \
      \          # ~6 MHz radar spectral width\n                 amplitude=1.0,  \
      \         # pulse amplitude\n                 phase_mod=True):         # phase\
      \ jitter for realism\n\n        gr.sync_block.__init__(\n            self,\n\
      \            name='DFS Radar Type-2 (Realistic Default)',\n            in_sig=None,\n\
      \            out_sig=[np.complex64]\n        )\n\n        self.samp_rate = float(samp_rate)\n\
      \        self.center_freq = float(center_freq)\n        self.pulse_width = max(1,\
      \ int((pulse_width_us / 1e6) * self.samp_rate))\n        self.pulses_per_burst\
      \ = int(pulses_per_burst)\n        self.pri = max(1, int((pri_us / 1e6) * self.samp_rate))\n\
      \        self.burst_interval = max(1, int((burst_interval_ms / 1000.0) * self.samp_rate))\n\
      \        self.radar_bw = float(radar_bw)\n        self.amplitude = float(amplitude)\n\
      \        self.phase_mod = bool(phase_mod)\n\n        self.t = 0  # time counter\n\
      \n    def _make_pulse(self, length):\n        \"\"\"Generate a realistic 5-us\
      \ radar pulse with FM jitter and shaping.\"\"\"\n        win = np.hanning(length\
      \ * 2)[0:length]\n        tvec = np.arange(length) / self.samp_rate\n\n    \
      \    # Tiny chirp inside pulse\n        chirp_bw = self.radar_bw * 0.15  # small\
      \ fraction of radar BW\n        k = chirp_bw / (length / self.samp_rate)\n \
      \       phase = 2*np.pi * (0.5 * k * tvec**2)\n\n        if self.phase_mod:\n\
      \            phase += np.random.randn(length) * 0.02\n\n        pulse = (self.amplitude\
      \ * win) * np.exp(1j * phase)\n\n        return pulse.astype(np.complex64)\n\
      \n    def work(self, input_items, output_items):\n        out = output_items[0]\n\
      \        n = len(out)\n        buf = np.zeros(n, dtype=np.complex64)\n\n   \
      \     t_local = self.t + np.arange(n)\n        cycle_pos = t_local % self.burst_interval\n\
      \n        for p in range(self.pulses_per_burst):\n            start = p * self.pri\n\
      \            end = start + self.pulse_width\n\n            mask = np.logical_and(cycle_pos\
      \ >= start, cycle_pos < end)\n            if not np.any(mask):\n           \
      \     continue\n\n            pulse = self._make_pulse(self.pulse_width)\n \
      \           idx = np.where(mask)[0]\n            pos = (cycle_pos[idx] - start).astype(int)\n\
      \            buf[idx] += pulse[pos]\n\n        # add light clutter noise (band-limited)\n\
      \        noise = (np.random.normal(0, 0.005, n) +\n                 1j * np.random.normal(0,\
      \ 0.005, n))\n\n        F = np.fft.fftshift(np.fft.fft(noise))\n        freqs\
      \ = np.linspace(-0.5, 0.5, n, endpoint=False) * self.samp_rate\n        sigma\
      \ = self.radar_bw / 2\n        mask = np.exp(-0.5 * (freqs / sigma)**2)\n  \
      \      F *= mask\n        clutter = np.fft.ifft(np.fft.ifftshift(F))\n\n   \
      \     buf += 0.05 * clutter.astype(np.complex64)\n\n        out[:] = buf\n \
      \       self.t += n\n        return n\n\n"
    affinity: ''
    alias: ''
    amplitude: '1.0'
    burst_interval_ms: '250'
    center_freq: '5260000000.0'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    phase_mod: 'True'
    pri_us: '200.0'
    pulse_width_us: '5.0'
    pulses_per_burst: '10'
    radar_bw: '6000000.0'
    samp_rate: '20000000.0'
  states:
    _io_cache: '(''DFS Radar Type-2 (Realistic Default)'', ''blk'', [(''samp_rate'',
      ''20000000.0''), (''center_freq'', ''5260000000.0''), (''pulse_width_us'', ''5.0''),
      (''pri_us'', ''200.0''), (''pulses_per_burst'', ''10''), (''burst_interval_ms'',
      ''250''), (''radar_bw'', ''6000000.0''), (''amplitude'', ''1.0''), (''phase_mod'',
      ''True'')], [], [(''0'', ''complex'', 1)], ''\n    Realistic DFS Radar Type-2
      (FCC / ETSI Standard)\n    - Pulse width: 5 us\n    - PRI: 200 us\n    - Pulses
      per burst: 10\n    - Burst interval: 250 ms\n    - Bandwidth ~6 MHz\n    '',
      [''amplitude'', ''center_freq'', ''phase_mod'', ''pulses_per_burst'', ''radar_bw'',
      ''samp_rate''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [48, 1020.0]
    rotation: 0
    state: enabled
- name: epy_block_6
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    DFS Radar Combo (Type-1 + Type-2)\n    REALISTIC DEFAULT VALUES\
      \ (FCC/ETSI)\n    - Alternates Type-1 and Type-2 radar every 1 second\n    -\
      \ Type-1: 1us PW, 9 pulses, 1428us PRI, 1s interval\n    - Type-2: 5us PW, 10\
      \ pulses, 200us PRI, 250ms interval\n    - Simulation-only, safe for QT sinks\n\
      \    \"\"\"\n\n    def __init__(self,\n                 samp_rate=20e6,    \
      \         # REQUIRED for microsecond pulses\n                 switch_interval_s=1.0,\
      \      # switch radar mode every 1 second\n\n                 # ---------- TYPE\
      \ 1 DEFAULTS ----------\n                 t1_pulse_width_us=1.0,      # 1 \xB5\
      s\n                 t1_pulses_per_burst=9,      # 9 pulses\n               \
      \  t1_pri_us=1428.0,           # 1428 \xB5s PRI\n                 t1_burst_interval_ms=1000,\
      \  # burst every 1 sec\n                 t1_bw=3e6,                  # 3 MHz\
      \ radar BW\n\n                 # ---------- TYPE 2 DEFAULTS ----------\n   \
      \              t2_pulse_width_us=5.0,      # 5 \xB5s\n                 t2_pulses_per_burst=10,\
      \     # 10 pulses\n                 t2_pri_us=200.0,            # 200 \xB5s\
      \ PRI\n                 t2_burst_interval_ms=250,   # burst every 0.25 sec\n\
      \                 t2_bw=6e6,                  # 6 MHz radar BW\n\n         \
      \        amplitude=1.0):              # default power\n        gr.sync_block.__init__(\n\
      \            self,\n            name='DFS Radar Combo (Type1+Type2)',\n    \
      \        in_sig=None,\n            out_sig=[np.complex64]\n        )\n\n   \
      \     self.samp_rate = float(samp_rate)\n        self.switch_interval = int(samp_rate\
      \ * switch_interval_s)\n        self.amplitude = float(amplitude)\n\n      \
      \  # Store Type-1 parameters\n        self.t1_pw = int((t1_pulse_width_us/1e6)*samp_rate)\n\
      \        self.t1_ppb = int(t1_pulses_per_burst)\n        self.t1_pri = int((t1_pri_us/1e6)*samp_rate)\n\
      \        self.t1_burst = int((t1_burst_interval_ms/1000.0)*samp_rate)\n    \
      \    self.t1_bw = float(t1_bw)\n\n        # Store Type-2 parameters\n      \
      \  self.t2_pw = int((t2_pulse_width_us/1e6)*samp_rate)\n        self.t2_ppb\
      \ = int(t2_pulses_per_burst)\n        self.t2_pri = int((t2_pri_us/1e6)*samp_rate)\n\
      \        self.t2_burst = int((t2_burst_interval_ms/1000.0)*samp_rate)\n    \
      \    self.t2_bw = float(t2_bw)\n\n        self.t = 0  # internal time counter\n\
      \n    # --------------------------------------------------------------------\n\
      \    def _make_pulse(self, length, bw):\n        \"\"\"Generate a shaped radar\
      \ pulse with small chirp.\"\"\"\n        win = np.hanning(length*2)[0:length]\n\
      \        tvec = np.arange(length) / self.samp_rate\n\n        # small chirp\
      \ for realism\n        chirp_bw = bw * 0.1\n        k = chirp_bw / (length /\
      \ self.samp_rate)\n        phase = 2*np.pi * (0.5*k*tvec*tvec)\n\n        pulse\
      \ = (self.amplitude * win) * np.exp(1j*phase)\n\n        # tiny noise for realism\n\
      \        pulse += (np.random.randn(length)*0.01 + 1j*np.random.randn(length)*0.01)\n\
      \n        return pulse.astype(np.complex64)\n\n    # --------------------------------------------------------------------\n\
      \    def _place_radar(self, buf, t_local, pw, ppb, pri, burst_interval, bw):\n\
      \        \"\"\"Place burst pulses into the buffer for one radar type.\"\"\"\n\
      \        cycle_pos = t_local % burst_interval\n        template = self._make_pulse(pw,\
      \ bw)\n\n        for p in range(ppb):\n            start = p * pri\n       \
      \     end = start + pw\n\n            mask = np.logical_and(cycle_pos >= start,\
      \ cycle_pos < end)\n            if not np.any(mask):\n                continue\n\
      \n            idx = np.where(mask)[0]\n            pos = ((cycle_pos[idx]-start).astype(int))\n\
      \            pos = np.clip(pos, 0, pw-1)\n\n            buf[idx] += template[pos]\n\
      \n        return buf\n\n    # --------------------------------------------------------------------\n\
      \    def work(self, input_items, output_items):\n        out = output_items[0]\n\
      \        n = len(out)\n        t_local = self.t + np.arange(n)\n\n        buf\
      \ = np.zeros(n, dtype=np.complex64)\n\n        # Decide current mode (Type1\
      \ or Type2)\n        mode = (self.t // self.switch_interval) % 2\n\n       \
      \ if mode == 0:\n            # ---------------- TYPE 1 ACTIVE ----------------\n\
      \            buf = self._place_radar(\n                buf, t_local,\n     \
      \           self.t1_pw, self.t1_ppb,\n                self.t1_pri, self.t1_burst,\
      \ self.t1_bw\n            )\n        else:\n            # ---------------- TYPE\
      \ 2 ACTIVE ----------------\n            buf = self._place_radar(\n        \
      \        buf, t_local,\n                self.t2_pw, self.t2_ppb,\n         \
      \       self.t2_pri, self.t2_burst, self.t2_bw\n            )\n\n        out[:]\
      \ = buf\n        self.t += n\n        return n\n\n"
    affinity: ''
    alias: ''
    amplitude: '1.0'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: '20000000.0'
    switch_interval_s: '1.0'
    t1_burst_interval_ms: '1000'
    t1_bw: '3000000.0'
    t1_pri_us: '1428.0'
    t1_pulse_width_us: '1.0'
    t1_pulses_per_burst: '9'
    t2_burst_interval_ms: '250'
    t2_bw: '6000000.0'
    t2_pri_us: '200.0'
    t2_pulse_width_us: '5.0'
    t2_pulses_per_burst: '10'
  states:
    _io_cache: '(''DFS Radar Combo (Type1+Type2)'', ''blk'', [(''samp_rate'', ''20000000.0''),
      (''switch_interval_s'', ''1.0''), (''t1_pulse_width_us'', ''1.0''), (''t1_pulses_per_burst'',
      ''9''), (''t1_pri_us'', ''1428.0''), (''t1_burst_interval_ms'', ''1000''), (''t1_bw'',
      ''3000000.0''), (''t2_pulse_width_us'', ''5.0''), (''t2_pulses_per_burst'',
      ''10''), (''t2_pri_us'', ''200.0''), (''t2_burst_interval_ms'', ''250''), (''t2_bw'',
      ''6000000.0''), (''amplitude'', ''1.0'')], [], [(''0'', ''complex'', 1)], ''\n    DFS
      Radar Combo (Type-1 + Type-2)\n    REALISTIC DEFAULT VALUES (FCC/ETSI)\n    -
      Alternates Type-1 and Type-2 radar every 1 second\n    - Type-1: 1us PW, 9 pulses,
      1428us PRI, 1s interval\n    - Type-2: 5us PW, 10 pulses, 200us PRI, 250ms interval\n    -
      Simulation-only, safe for QT sinks\n    '', [''amplitude'', ''samp_rate'', ''t1_bw'',
      ''t2_bw''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [328, 1188.0]
    rotation: 0
    state: enabled
- name: epy_block_7
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nIntermittent Interference Injector (3 DFS types) with DFS\
      \ scheduler + JSONL logging.\n\nPort mapping (inputs, in order):\n  - in0 :\
      \ complex64  -> ip1 : DFS Type 1\n  - in1 : complex64  -> ip2 : DFS Type 2\n\
      \  - in2 : complex64  -> ip3 : DFS Type 1 + 2\n  - in3 : complex64  -> dfs_in\
      \ : DFS-monitor signal used to detect radar (power measured)\n\nOutput:\n  -\
      \ out  : complex64 combined interference (or zeros when idle/hold-off)\n\nLogging:\n\
      \  - Newline-delimited JSON appended to log_path\n  - Events: injection_start,\
      \ injection_terminated_by_dfs, dfs_detected\n\"\"\"\n\nimport numpy as np\n\
      import json\nimport os\nimport math\nfrom datetime import datetime, timezone\n\
      from gnuradio import gr\n\n# Human-readable labels for the three interference\
      \ inputs\nINTERFERENCE_MAP = {\n    0: \"DFS_Type_1\",        # in0 / ip1\n\
      \    1: \"DFS_Type_2\",        # in1 / ip2\n    2: \"DFS_Type_1_and_2\"   #\
      \ in2 / ip3\n}\n\n\nclass blk(gr.sync_block):\n    def __init__(self,\n    \
      \             example_param=1.0,\n\n                 # timing / scheduling\n\
      \                 sample_rate=20e6,\n                 mean_interval_seconds=2.0,\n\
      \                 inject_duration_seconds=0.1,\n\n                 # pure injection\
      \ (occasional long single-source injection)\n                 pure_inject_enabled=True,\n\
      \                 pure_injection_probability=0.02,\n                 pure_inject_duration_seconds=20.0,\n\
      \n                 # DFS scheduler options\n                 dfs_monitor_enabled=True,\n\
      \                 dfs_detection_threshold=1e-6,\n                 dfs_holdoff_seconds=60.0,\n\
      \n                 # logging / output\n                 log_path=\"/tmp/interference_log.jsonl\"\
      ,\n                 log_every_injection=True,\n                 output_when_idle=\"\
      zeros\"):\n        \"\"\"\n        Constructor parameters appear in GRC as block\
      \ parameters. All have defaults.\n        \"\"\"\n        # Inputs: 3 interferers\
      \ + 1 dfs monitor\n        gr.sync_block.__init__(\n            self,\n    \
      \        name='Interference Injector (3 DFS types) with DFS scheduler',\n  \
      \          in_sig=[np.complex64, np.complex64, np.complex64, np.complex64],\n\
      \            out_sig=[np.complex64]\n        )\n\n        # Exposed parameters\n\
      \        self.example_param = example_param\n        self.sample_rate = float(sample_rate)\n\
      \        self.mean_interval_seconds = float(mean_interval_seconds)\n       \
      \ self.inject_duration_seconds = float(inject_duration_seconds)\n\n        self.pure_inject_enabled\
      \ = bool(pure_inject_enabled)\n        self.pure_injection_probability = float(pure_injection_probability)\n\
      \        self.pure_inject_duration_seconds = float(pure_inject_duration_seconds)\n\
      \n        self.dfs_monitor_enabled = bool(dfs_monitor_enabled)\n        self.dfs_detection_threshold\
      \ = float(dfs_detection_threshold)\n        self.dfs_holdoff_seconds = float(dfs_holdoff_seconds)\n\
      \n        self.log_path = str(log_path)\n        self.log_every_injection =\
      \ bool(log_every_injection)\n        self.output_when_idle = str(output_when_idle)\n\
      \n        # Internal state\n        self._time_accumulator_seconds = 0.0\n \
      \       self._injection_remaining_seconds = 0.0\n        self._next_wait_seconds\
      \ = self._sample_next_wait()\n        self._current_coeffs = None  # numpy array\
      \ length 3 when injecting\n        self._injection_id = 0\n\n        self._is_current_pure\
      \ = False\n        self._pure_source_index = None  # 0..2\n\n        # DFS state\n\
      \        self._dfs_holdoff_remaining = 0.0\n        self._last_dfs_detect_time\
      \ = None\n\n        # Ensure log folder exists\n        log_dir = os.path.dirname(os.path.abspath(self.log_path))\n\
      \        if log_dir and not os.path.exists(log_dir):\n            try:\n   \
      \             os.makedirs(log_dir, exist_ok=True)\n            except Exception:\n\
      \                pass\n\n    # ---------------------------\n    # Internal helpers\n\
      \    # ---------------------------\n    def _sample_next_wait(self):\n     \
      \   mean = max(1e-12, float(self.mean_interval_seconds))\n        return np.random.exponential(mean)\n\
      \n    def _write_log(self, record):\n        try:\n            with open(self.log_path,\
      \ \"a\", encoding=\"utf-8\") as f:\n                f.write(json.dumps(record,\
      \ default=str) + \"\\n\")\n        except Exception:\n            # Do not let\
      \ logging failures crash the flowgraph\n            pass\n\n    def _start_injection(self,\
      \ force_pure=False):\n        \"\"\"\n        Begin a new injection (mixed or\
      \ pure). Logs injection start if enabled.\n        \"\"\"\n        self._injection_id\
      \ += 1\n        self._is_current_pure = False\n        self._pure_source_index\
      \ = None\n\n        will_be_pure = False\n        if self.pure_inject_enabled:\n\
      \            if force_pure:\n                will_be_pure = True\n         \
      \   else:\n                if np.random.random() < self.pure_injection_probability:\n\
      \                    will_be_pure = True\n\n        if will_be_pure:\n     \
      \       src_idx = int(np.random.randint(0, 3))\n            self._pure_source_index\
      \ = src_idx\n            self._is_current_pure = True\n            coeffs =\
      \ np.zeros(3, dtype=float)\n            coeffs[src_idx] = 1.0\n            self._current_coeffs\
      \ = coeffs\n            self._injection_remaining_seconds = float(self.pure_inject_duration_seconds)\n\
      \        else:\n            coeffs = np.random.random(3)  # three random floats\
      \ in [0,1)\n            self._current_coeffs = coeffs.astype(float)\n      \
      \      self._injection_remaining_seconds = float(self.inject_duration_seconds)\n\
      \n        # Log injection start\n        if self.log_every_injection:\n    \
      \        dominant_idx = int(np.argmax(self._current_coeffs))\n            record\
      \ = {\n                \"event\": \"injection_start\",\n                \"injection_id\"\
      : int(self._injection_id),\n                \"start_time_utc\": datetime.now(timezone.utc).isoformat(),\n\
      \                \"is_pure_injection\": bool(self._is_current_pure),\n     \
      \           \"pure_source_index\": None if self._pure_source_index is None else\
      \ int(self._pure_source_index),\n                \"pure_source_type\": None\
      \ if self._pure_source_index is None else INTERFERENCE_MAP.get(self._pure_source_index),\n\
      \                \"mean_interval_seconds\": float(self.mean_interval_seconds),\n\
      \                \"inject_duration_seconds\": float(self._injection_remaining_seconds),\n\
      \                \"coefficients\": { INTERFERENCE_MAP[i]: float(self._current_coeffs[i])\
      \ for i in range(3) },\n                \"dominant_index\": dominant_idx,\n\
      \                \"dominant_type\": INTERFERENCE_MAP.get(dominant_idx, f\"input_{dominant_idx}\"\
      )\n            }\n            self._write_log(record)\n\n        # reset wait\
      \ accumulator and sample next wait for after injection\n        self._time_accumulator_seconds\
      \ = 0.0\n        self._next_wait_seconds = self._sample_next_wait()\n\n    def\
      \ _handle_dfs_detection(self, dfs_power):\n        \"\"\"\n        Called when\
      \ DFS detection threshold is exceeded.\n        Terminates any active injection,\
      \ enters hold-off, and logs the event.\n        \"\"\"\n        # If an injection\
      \ was active, log its termination\n        if self._injection_remaining_seconds\
      \ > 0.0 and self.log_every_injection:\n            record_term = {\n       \
      \         \"event\": \"injection_terminated_by_dfs\",\n                \"injection_id\"\
      : int(self._injection_id),\n                \"time_utc\": datetime.now(timezone.utc).isoformat(),\n\
      \                \"remaining_injection_seconds\": float(self._injection_remaining_seconds)\n\
      \            }\n            self._write_log(record_term)\n\n        # Clear\
      \ injection state\n        self._injection_remaining_seconds = 0.0\n       \
      \ self._current_coeffs = None\n        self._is_current_pure = False\n     \
      \   self._pure_source_index = None\n\n        # Enter hold-off\n        self._dfs_holdoff_remaining\
      \ = float(self.dfs_holdoff_seconds)\n        self._last_dfs_detect_time = datetime.now(timezone.utc)\n\
      \n        # Log DFS detection\n        record = {\n            \"event\": \"\
      dfs_detected\",\n            \"time_utc\": datetime.now(timezone.utc).isoformat(),\n\
      \            \"dfs_power\": float(dfs_power),\n            \"holdoff_seconds\"\
      : float(self._dfs_holdoff_remaining)\n        }\n        self._write_log(record)\n\
      \n        # Reset waiting accumulator so schedule restarts after hold-off\n\
      \        self._time_accumulator_seconds = 0.0\n        self._next_wait_seconds\
      \ = self._sample_next_wait()\n\n    # ---------------------------\n    # Main\
      \ processing\n    # ---------------------------\n    def work(self, input_items,\
      \ output_items):\n        # Inputs: in0 (DFS Type 1), in1 (DFS Type 2), in2\
      \ (DFS Type 1+2), dfs_in (monitor)\n        in0 = input_items[0]\n        in1\
      \ = input_items[1]\n        in2 = input_items[2]\n        dfs_in = input_items[3]\n\
      \n        # samples to process\n        n = min(len(in0), len(in1), len(in2),\
      \ len(dfs_in))\n        if n <= 0:\n            return 0\n\n        elapsed_seconds\
      \ = float(n) / max(1.0, float(self.sample_rate))\n        out = np.empty(n,\
      \ dtype=np.complex64)\n\n        samples_filled = 0\n        remaining_samples\
      \ = n\n        local_time = 0.0\n\n        # Process by segments (idle / injection\
      \ / hold-off boundaries)\n        while remaining_samples > 0:\n           \
      \ # Handle DFS hold-off first\n            if self._dfs_holdoff_remaining >\
      \ 0.0:\n                seg_seconds = min(self._dfs_holdoff_remaining, elapsed_seconds\
      \ - local_time)\n                seg_samples = int(math.floor(seg_seconds *\
      \ self.sample_rate + 1e-12))\n                seg_samples = min(seg_samples,\
      \ remaining_samples)\n                if seg_samples <= 0:\n               \
      \     seg_samples = 1\n\n                # Idle output during hold-off\n   \
      \             out[samples_filled:samples_filled+seg_samples] = 0\n\n       \
      \         used_seconds = float(seg_samples) / self.sample_rate\n           \
      \     self._dfs_holdoff_remaining -= used_seconds\n                local_time\
      \ += used_seconds\n                remaining_samples -= seg_samples\n      \
      \          samples_filled += seg_samples\n\n                # Continue, still\
      \ monitor dfs_in\n                continue\n\n            # If not currently\
      \ injecting, we are waiting\n            if self._injection_remaining_seconds\
      \ <= 0.0:\n                time_until_next = self._next_wait_seconds - self._time_accumulator_seconds\n\
      \                time_until_next = max(0.0, time_until_next)\n\n           \
      \     # If next injection starts within this chunk\n                if local_time\
      \ + time_until_next < elapsed_seconds:\n                    seg_seconds = time_until_next\n\
      \                    seg_samples = int(math.floor(seg_seconds * self.sample_rate\
      \ + 1e-12))\n                    seg_samples = min(seg_samples, remaining_samples)\n\
      \                    if seg_samples <= 0:\n                        seg_samples\
      \ = 1\n\n                    # Idle output\n                    out[samples_filled:samples_filled+seg_samples]\
      \ = 0\n\n                    # Check DFS power over this idle segment\n    \
      \                dfs_segment = dfs_in[samples_filled:samples_filled+seg_samples]\n\
      \                    dfs_power = float(np.mean(np.abs(dfs_segment) ** 2)) if\
      \ seg_samples > 0 else 0.0\n\n                    used_seconds = float(seg_samples)\
      \ / self.sample_rate\n                    self._time_accumulator_seconds +=\
      \ used_seconds\n                    local_time += used_seconds\n           \
      \         remaining_samples -= seg_samples\n                    samples_filled\
      \ += seg_samples\n\n                    # DFS detection?\n                 \
      \   if self.dfs_monitor_enabled and dfs_power >= self.dfs_detection_threshold:\n\
      \                        self._handle_dfs_detection(dfs_power)\n           \
      \             continue\n\n                    # Wait finished -> start injection\
      \ if not suppressed\n                    if self._time_accumulator_seconds >=\
      \ self._next_wait_seconds - 1e-12:\n                        if self._dfs_holdoff_remaining\
      \ <= 0.0:\n                            self._start_injection()\n           \
      \             else:\n                            pass\n                else:\n\
      \                    # Entire remaining chunk is idle\n                    seg_samples\
      \ = remaining_samples\n                    out[samples_filled:samples_filled+seg_samples]\
      \ = 0\n\n                    dfs_segment = dfs_in[samples_filled:samples_filled+seg_samples]\n\
      \                    dfs_power = float(np.mean(np.abs(dfs_segment) ** 2)) if\
      \ seg_samples > 0 else 0.0\n\n                    used_seconds = float(seg_samples)\
      \ / self.sample_rate\n                    self._time_accumulator_seconds +=\
      \ used_seconds\n                    local_time += used_seconds\n           \
      \         remaining_samples -= seg_samples\n                    samples_filled\
      \ += seg_samples\n\n                    if self.dfs_monitor_enabled and dfs_power\
      \ >= self.dfs_detection_threshold:\n                        self._handle_dfs_detection(dfs_power)\n\
      \                        continue\n                    break\n            else:\n\
      \                # Injection active\n                seg_seconds = min(self._injection_remaining_seconds,\
      \ elapsed_seconds - local_time)\n                seg_samples = int(math.floor(seg_seconds\
      \ * self.sample_rate + 1e-12))\n                seg_samples = min(seg_samples,\
      \ remaining_samples)\n                if seg_samples <= 0:\n               \
      \     seg_samples = 1\n\n                start_idx = samples_filled\n      \
      \          end_idx = samples_filled + seg_samples\n\n                # Monitor\
      \ DFS inside injection window\n                dfs_segment = dfs_in[start_idx:end_idx]\n\
      \                dfs_power = float(np.mean(np.abs(dfs_segment) ** 2)) if seg_samples\
      \ > 0 else 0.0\n\n                if self.dfs_monitor_enabled and dfs_power\
      \ >= self.dfs_detection_threshold:\n                    # Handle DFS detection:\
      \ terminate injection immediately\n                    self._handle_dfs_detection(dfs_power)\n\
      \                    out[start_idx:end_idx] = 0\n                    used_seconds\
      \ = float(seg_samples) / self.sample_rate\n                    local_time +=\
      \ used_seconds\n                    remaining_samples -= seg_samples\n     \
      \               samples_filled += seg_samples\n                    continue\n\
      \n                # No DFS detection -> produce injection output\n         \
      \       if self._is_current_pure and self._pure_source_index is not None:\n\
      \                    if self._pure_source_index == 0:\n                    \
      \    out[start_idx:end_idx] = in0[start_idx:end_idx]\n                    elif\
      \ self._pure_source_index == 1:\n                        out[start_idx:end_idx]\
      \ = in1[start_idx:end_idx]\n                    elif self._pure_source_index\
      \ == 2:\n                        out[start_idx:end_idx] = in2[start_idx:end_idx]\n\
      \                    else:\n                        out[start_idx:end_idx] =\
      \ 0\n                else:\n                    a, b, c = self._current_coeffs.tolist()\
      \ if self._current_coeffs is not None else (0.0, 0.0, 0.0)\n               \
      \     out[start_idx:end_idx] = (a * in0[start_idx:end_idx]\n               \
      \                               + b * in1[start_idx:end_idx]\n             \
      \                                 + c * in2[start_idx:end_idx])\n\n        \
      \        used_seconds = float(seg_samples) / self.sample_rate\n            \
      \    self._injection_remaining_seconds -= used_seconds\n                local_time\
      \ += used_seconds\n                remaining_samples -= seg_samples\n      \
      \          samples_filled += seg_samples\n\n                # If injection ended,\
      \ reset state\n                if self._injection_remaining_seconds <= 0.0:\n\
      \                    self._current_coeffs = None\n                    self._is_current_pure\
      \ = False\n                    self._pure_source_index = None\n            \
      \        self._time_accumulator_seconds = 0.0\n                    self._next_wait_seconds\
      \ = self._sample_next_wait()\n\n        # write output buffer\n        output_items[0][:n]\
      \ = out\n        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    dfs_detection_threshold: 1e-06
    dfs_holdoff_seconds: '60.0'
    dfs_monitor_enabled: 'True'
    example_param: '1.0'
    inject_duration_seconds: '10'
    log_every_injection: 'True'
    log_path: '"Injection.json"'
    maxoutbuf: '0'
    mean_interval_seconds: '2'
    minoutbuf: '0'
    output_when_idle: '"Zeros"'
    pure_inject_duration_seconds: '20'
    pure_inject_enabled: 'True'
    pure_injection_probability: '0.25'
    sample_rate: samp_rate
  states:
    _io_cache: ('Interference Injector (3 DFS types) with DFS scheduler', 'blk', [('example_param',
      '1.0'), ('sample_rate', '20000000.0'), ('mean_interval_seconds', '2.0'), ('inject_duration_seconds',
      '0.1'), ('pure_inject_enabled', 'True'), ('pure_injection_probability', '0.02'),
      ('pure_inject_duration_seconds', '20.0'), ('dfs_monitor_enabled', 'True'), ('dfs_detection_threshold',
      '1e-06'), ('dfs_holdoff_seconds', '60.0'), ('log_path', "'/tmp/interference_log.jsonl'"),
      ('log_every_injection', 'True'), ('output_when_idle', "'zeros'")], [('0', 'complex',
      1), ('1', 'complex', 1), ('2', 'complex', 1), ('3', 'complex', 1)], [('0', 'complex',
      1)], '\n        Constructor parameters appear in GRC as block parameters. All
      have defaults.\n        ', ['dfs_detection_threshold', 'dfs_holdoff_seconds',
      'dfs_monitor_enabled', 'example_param', 'inject_duration_seconds', 'log_every_injection',
      'log_path', 'mean_interval_seconds', 'output_when_idle', 'pure_inject_duration_seconds',
      'pure_inject_enabled', 'pure_injection_probability', 'sample_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [800, 700.0]
    rotation: 0
    state: enabled
- name: epy_block_8
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nDFS Monitor Signal Generator (STANDARD DFS TEST WAVEFORM)\n\
      \nGenerates radar-like pulses used as the DFS detection input.\nFollows standard\
      \ DFS radar characteristics:\n- Pulse width: 1 \xB5s\n- PRF: 300 Hz\n- Amplitude:\
      \ 0.1\n- Noise floor: 1e-7\n- Sample rate: 20 MHz\n\"\"\"\n\nimport numpy as\
      \ np\nfrom gnuradio import gr\nimport math\n\nclass blk(gr.sync_block):\n  \
      \  def __init__(self,\n                 sample_rate=20e6,          # STANDARD\
      \ DFS test bandwidth\n                 pulse_width_us=1.0,        # 1 \xB5s\
      \ pulse width\n                 prf_hz=300.0,              # Pulse repetition\
      \ frequency\n                 pulse_amplitude=0.1,       # Radar peak amplitude\n\
      \                 noise_power=1e-7):         # Noise floor power\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"DFS Monitor (Standard Radar)\",\n   \
      \         in_sig=None,\n            out_sig=[np.complex64]\n        )\n\n  \
      \      self.sample_rate = float(sample_rate)\n        self.pulse_width_seconds\
      \ = float(pulse_width_us) * 1e-6\n        self.prf_hz = float(prf_hz)\n    \
      \    self.pulse_amplitude = float(pulse_amplitude)\n        self.noise_power\
      \ = float(noise_power)\n\n        # Derived parameters\n        self.pulse_samples\
      \ = int(self.pulse_width_seconds * self.sample_rate)\n        self.samples_per_pulse_period\
      \ = int(self.sample_rate / self.prf_hz)\n\n        # Internal counter\n    \
      \    self._sample_counter = 0\n\n    def work(self, input_items, output_items):\n\
      \        out = output_items[0]\n        n = len(out)\n\n        # Time vector\n\
      \        t = (self._sample_counter + np.arange(n)) / self.sample_rate\n\n  \
      \      # Base noise floor\n        sigma = math.sqrt(self.noise_power / 2.0)\n\
      \        noise = (np.random.normal(scale=sigma, size=n) +\n                \
      \ 1j * np.random.normal(scale=sigma, size=n))\n\n        # Start with noise\
      \ only\n        sig = noise.astype(np.complex64)\n\n        # Radar pulse periodicity\
      \ logic\n        for i in range(n):\n            sample_index = self._sample_counter\
      \ + i\n            pos_in_period = sample_index % self.samples_per_pulse_period\n\
      \n            if pos_in_period < self.pulse_samples:\n                # Insert\
      \ radar pulse (simple CW pulse)\n                sig[i] += self.pulse_amplitude\n\
      \n        # Output\n        out[:] = sig\n        self._sample_counter += n\n\
      \        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_power: 1e-07
    prf_hz: '300.0'
    pulse_amplitude: '0.1'
    pulse_width_us: '5000'
    sample_rate: '20000000.0'
  states:
    _io_cache: ('DFS Monitor (Standard Radar)', 'blk', [('sample_rate', '20000000.0'),
      ('pulse_width_us', '1.0'), ('prf_hz', '300.0'), ('pulse_amplitude', '0.1'),
      ('noise_power', '1e-07')], [], [('0', 'complex', 1)], '', ['noise_power', 'prf_hz',
      'pulse_amplitude', 'sample_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [632, 1336.0]
    rotation: 0
    state: enabled
- name: iio_pluto_sink_0
  id: iio_pluto_sink
  parameters:
    affinity: ''
    alias: ''
    attenuation1: '5.0'
    bandwidth: '20000000'
    buffer_size: '32768'
    comment: ''
    cyclic: 'True'
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: Injection_Frequency
    fstop: '0'
    len_tag_key: ''
    samplerate: int(samp_rate)
    type: fc32
    uri: 192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1224, 988.0]
    rotation: 0
    state: enabled
- name: iio_pluto_source_0
  id: iio_pluto_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '20000000'
    bbdc: 'True'
    buffer_size: '32768'
    comment: ''
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: Injection_Frequency
    fstop: '0'
    gain1: '''slow_attack'''
    len_tag_key: packet_len
    manual_gain1: '64'
    maxoutbuf: '0'
    minoutbuf: '0'
    quadrature: 'True'
    rfdc: 'True'
    samplerate: int(samp_rate)
    type: fc32
    uri: 192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1224, 564.0]
    rotation: 0
    state: enabled
- name: qtgui_freq_sink_x_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: int(5.44e6)
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Transmitted"'
    nconnections: '1'
    norm_window: 'False'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1000, 216.0]
    rotation: 0
    state: disabled
- name: qtgui_freq_sink_x_0_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: Injection_Frequency
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Recieved Watterfall Plot"'
    nconnections: '1'
    norm_window: 'False'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1632, 772.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Trabsmitted"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1016, 352.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Recived Time Domain"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1648, 548.0]
    rotation: 0
    state: enabled
- name: qtgui_waterfall_sink_x_0
  id: qtgui_waterfall_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '0'
    color10: '0'
    color2: '0'
    color3: '0'
    color4: '0'
    color5: '0'
    color6: '0'
    color7: '0'
    color8: '0'
    color9: '0'
    comment: ''
    fc: int(5.44e6)
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    int_max: '10'
    int_min: '-140'
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Transmitted"'
    nconnections: '1'
    showports: 'False'
    type: complex
    update_time: '0.10'
    wintype: window.WIN_BLACKMAN_hARRIS
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1008, 472.0]
    rotation: 0
    state: disabled
- name: qtgui_waterfall_sink_x_0_0
  id: qtgui_waterfall_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '0'
    color10: '0'
    color2: '0'
    color3: '0'
    color4: '0'
    color5: '0'
    color6: '0'
    color7: '0'
    color8: '0'
    color9: '0'
    comment: ''
    fc: Injection_Frequency
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    int_max: '10'
    int_min: '-140'
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Recieved Frequency Domain"'
    nconnections: '1'
    showports: 'False'
    type: complex
    update_time: '0.10'
    wintype: window.WIN_BLACKMAN_hARRIS
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1632, 652.0]
    rotation: 0
    state: enabled

connections:
- [epy_block_0, '0', epy_block_7, '0']
- [epy_block_0, '0', qtgui_freq_sink_x_0, '0']
- [epy_block_0, '0', qtgui_time_sink_x_0, '0']
- [epy_block_0, '0', qtgui_waterfall_sink_x_0, '0']
- [epy_block_1, '0', epy_block_7, '1']
- [epy_block_1, '0', qtgui_freq_sink_x_0, '0']
- [epy_block_1, '0', qtgui_time_sink_x_0, '0']
- [epy_block_1, '0', qtgui_waterfall_sink_x_0, '0']
- [epy_block_2, '0', epy_block_7, '2']
- [epy_block_2, '0', qtgui_freq_sink_x_0, '0']
- [epy_block_2, '0', qtgui_waterfall_sink_x_0, '0']
- [epy_block_3, '0', epy_block_7, '3']
- [epy_block_3, '0', qtgui_freq_sink_x_0, '0']
- [epy_block_3, '0', qtgui_time_sink_x_0, '0']
- [epy_block_3, '0', qtgui_waterfall_sink_x_0, '0']
- [epy_block_4, '0', epy_block_7, '0']
- [epy_block_4, '0', qtgui_freq_sink_x_0, '0']
- [epy_block_4, '0', qtgui_time_sink_x_0, '0']
- [epy_block_4, '0', qtgui_waterfall_sink_x_0, '0']
- [epy_block_5, '0', epy_block_7, '1']
- [epy_block_6, '0', epy_block_7, '2']
- [epy_block_6, '0', qtgui_time_sink_x_0, '0']
- [epy_block_7, '0', iio_pluto_sink_0, '0']
- [epy_block_8, '0', epy_block_7, '3']
- [iio_pluto_source_0, '0', qtgui_freq_sink_x_0_0, '0']
- [iio_pluto_source_0, '0', qtgui_time_sink_x_0_0, '0']
- [iio_pluto_source_0, '0', qtgui_waterfall_sink_x_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.9.2
